export default {
  async scheduled(event, env, ctx) {
    console.log('Starting scheduled liver data scraping...');
    
    try {
      // å…¨ãƒšãƒ¼ã‚¸ã‹ã‚‰è©³ç´°æƒ…å ±ã‚’å–å¾—
      const allLiverData = await scrapeAllPagesWithAuthentication(env);
      
      // å‰å›ãƒ‡ãƒ¼ã‚¿ã¨æ¯”è¼ƒ
      const lastDataStr = env.LIVER_DATA ? await env.LIVER_DATA.get('latest_data') : null;
      const lastData = lastDataStr ? JSON.parse(lastDataStr) : null;
      
      // å¤‰æ›´ãŒã‚ã£ãŸå ´åˆã®ã¿ä¿å­˜
      const currentHash = generateHash(JSON.stringify(allLiverData) + Date.now()); 
      const lastHash = lastData ? generateHash(JSON.stringify(lastData.data)) : null;
      
      if (currentHash !== lastHash) {
        if (env.LIVER_DATA) {
          await env.LIVER_DATA.put('latest_data', JSON.stringify({
          timestamp: Date.now(),
          total: allLiverData.length,
          data: allLiverData,
          lastUpdate: new Date().toISOString()
        }));
        console.log(`âœ… Updated data: ${allLiverData.length} livers with detailed info`);
        }
      } else {
        console.log('â„¹ï¸ No changes detected, skipping update');
      }
      
    } catch (error) {
      console.error('âŒ Scraping failed:', error);
      // ã‚¨ãƒ©ãƒ¼æƒ…å ±ã‚‚ä¿å­˜
      if (env.LIVER_DATA) {
        await env.LIVER_DATA.put('last_error', JSON.stringify({
        timestamp: Date.now(),
        error: error.message,
        stack: error.stack
      }));
      }
    }
  },

  async fetch(request, env) {
    const url = new URL(request.url);
    
    // CORSè¨­å®š
    const corsHeaders = {
      'Access-Control-Allow-Origin': '*',
      'Access-Control-Allow-Methods': 'GET, OPTIONS',
      'Access-Control-Allow-Headers': 'Content-Type',
    };
    
    if (request.method === 'OPTIONS') {
      return new Response(null, { headers: corsHeaders });
    }
    
    // ğŸ”§ ä¿®æ­£: ã‚ˆã‚Šè©³ç´°ãªãƒ†ã‚¹ãƒˆç”¨ã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆ
    if (url.pathname === '/test') {
      return await testSingleLiverWithGender(env);
    }

    if (url.pathname === '/manual-scrape') {
      try {
        console.log('ğŸš€ Manual scraping triggered...');
        
        // scheduledå‡¦ç†ã¨åŒã˜ãƒ­ã‚¸ãƒƒã‚¯ã‚’å®Ÿè¡Œ
        const allLiverData = await scrapeAllPagesWithAuthentication(env);
        
        // å‰å›ãƒ‡ãƒ¼ã‚¿ã¨æ¯”è¼ƒ
        const lastDataStr = env.LIVER_DATA ? await env.LIVER_DATA.get('latest_data') : null;
        const lastData = lastDataStr ? JSON.parse(lastDataStr) : null;
        
        // å¤‰æ›´ãŒã‚ã£ãŸå ´åˆã®ã¿ä¿å­˜
        const currentHash = generateHash(JSON.stringify(allLiverData));
        const lastHash = lastData ? generateHash(JSON.stringify(lastData.data)) : null;
        
        let updated = false;
        console.log(`ğŸ” Detailed env debug:`);
        console.log(`- env type: ${typeof env}`);
        console.log(`- env keys: ${Object.keys(env)}`);
        console.log(`- LIVER_DATA exists: ${!!env.LIVER_DATA}`);
        console.log(`- LIVER_DATA type: ${typeof env.LIVER_DATA}`);
        console.log(`- IMAGE_HASHES exists: ${!!env.IMAGE_HASHES}`);
        console.log(`- IMAGES exists: ${!!env.IMAGES}`);

        try {
          console.log(`- LIVER_DATA.get test: attempting...`);
          const testResult = await env.LIVER_DATA.get('non_existent_key');
          console.log(`- LIVER_DATA.get test: success (result: ${testResult})`);
        } catch (kvError) {
          console.log(`- LIVER_DATA.get test: failed - ${kvError.message}`);
        }
        if (currentHash !== lastHash) {
          if (env.LIVER_DATA) {
            console.log(`ğŸ’¾ Attempting to save data...`);
            await env.LIVER_DATA.put('latest_data', JSON.stringify({
              timestamp: Date.now(),
              total: allLiverData.length,
              data: allLiverData,
              lastUpdate: new Date().toISOString()
            }));
            updated = true;
            console.log(`âœ… Updated data: ${allLiverData.length} livers with detailed info`);
          } else {
            console.log(`âŒ env.LIVER_DATA is undefined!`);  // â† è¿½åŠ 
          }
        } else {
          console.log('â„¹ï¸ No changes detected, skipping update');
        }
        console.log(`Final updated value: ${updated}`); 
        
        return new Response(JSON.stringify({
          success: true,
          message: 'Manual scraping completed',
          totalLivers: allLiverData.length,
          updated: updated,
          timestamp: new Date().toISOString(),
          sampleLiver: allLiverData[0] || null,
          allData: allLiverData
        }, null, 2), {
          headers: { 'Content-Type': 'application/json', ...corsHeaders }
        });
        
      } catch (error) {
        console.error('âŒ Manual scraping failed:', error);
        
        // ã‚¨ãƒ©ãƒ¼æƒ…å ±ã‚‚ä¿å­˜
        if (env.LIVER_DATA) {
          await env.LIVER_DATA.put('last_error', JSON.stringify({
            timestamp: Date.now(),
            error: error.message,
            stack: error.stack
          }));
        }
        
        return new Response(JSON.stringify({
          success: false,
          error: error.message,
          timestamp: new Date().toISOString()
        }, null, 2), {
          status: 500,
          headers: { 'Content-Type': 'application/json', ...corsHeaders }
        });
      }
    }

    // ğŸ†• ã‚¹ã‚¯ãƒ¬ã‚¤ãƒ”ãƒ³ã‚°é€²è¡ŒçŠ¶æ³ã‚’ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ ç¢ºèª
    if (url.pathname === '/scrape-status') {
      try {
        const latestData = env.LIVER_DATA ? await env.LIVER_DATA.get('latest_data') : null;
        const lastError = env.LIVER_DATA ? await env.LIVER_DATA.get('last_error') : null;
        
        let parsedData = null;
        let parsedError = null;
        
        if (latestData) {
          parsedData = JSON.parse(latestData);
        }
        
        if (lastError) {
          parsedError = JSON.parse(lastError);
        }
        
        return new Response(JSON.stringify({
          status: 'running',
          hasData: !!parsedData,
          totalLivers: parsedData ? parsedData.total : 0,
          lastUpdate: parsedData ? parsedData.lastUpdate : null,
          lastUpdateTimestamp: parsedData ? parsedData.timestamp : null,
          hasError: !!parsedError,
          lastError: parsedError,
          sampleLivers: parsedData && parsedData.data ? 
            parsedData.data.slice(0, 3).map(liver => ({
              name: liver.name,
              platform: liver.platform,
              followers: liver.followers,
              hasGender: !!(liver.profileInfo && liver.profileInfo.gender),
              genderFound: liver.genderFound
            })) : []
        }, null, 2), {
          headers: { 'Content-Type': 'application/json', ...corsHeaders }
        });
        
      } catch (error) {
        return new Response(JSON.stringify({
          error: 'Failed to get status: ' + error.message
        }), {
          status: 500,
          headers: { 'Content-Type': 'application/json', ...corsHeaders }
        });
      }
    }

    // ğŸ†• æ–°ã—ã„ãƒ‡ãƒãƒƒã‚°ã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆ: ãƒ­ã‚°ã‚¤ãƒ³çŠ¶æ…‹ç¢ºèª
    if (url.pathname === '/debug-login-only') {
      try {
        const loginResult = await performRobustLogin(env);
        return new Response(JSON.stringify({
          loginSuccess: loginResult.success,
          loginMethod: loginResult.method,
          cookiesLength: loginResult.cookies.length,
          cookiesPreview: loginResult.cookies.substring(0, 100),
          error: loginResult.error
        }, null, 2), {
          headers: { 'Content-Type': 'application/json', ...corsHeaders }
        });
      } catch (error) {
        return new Response(JSON.stringify({ error: error.message }), {
          headers: { 'Content-Type': 'application/json', ...corsHeaders }
        });
      }
    }

    // ğŸ†• æ–°ã—ã„ãƒ‡ãƒãƒƒã‚°ã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆ: ãƒªã‚¹ãƒˆè§£æã®ã¿
    if (url.pathname === '/debug-list-parsing') {
      try {
        const loginResult = await performRobustLogin(env);
        if (!loginResult.success) {
          return new Response(JSON.stringify({ error: 'Login failed' }), {
            headers: { 'Content-Type': 'application/json', ...corsHeaders }
          });
        }
        
        const listResponse = await fetch('https://www.comisapolive.com/liver/list/?q=&collaboration=&achievements=&rank=&app=&follower1=&follower2=&since=&gender=&age1=&age2=&regist=&search=1', {
          headers: {
            'Cookie': loginResult.cookies,
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36',
            'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8',
            'Accept-Language': 'ja,en-US;q=0.9,en;q=0.8',
            'Referer': 'https://www.comisapolive.com/'
          }
        });
        
        const html = await listResponse.text();
        
        // ã‚ˆã‚Šè©³ç´°ãªè§£æ
        const analysis = {
          responseStatus: listResponse.status,
          responseUrl: listResponse.url,
          htmlLength: html.length,
          // HTMLæ§‹é€ ã®åˆ†æ
          structure: {
            hasLiversItem: html.includes('livers_item'),
            hasLiversList: html.includes('livers_list'),
            hasModal: html.includes('modal'),
            hasGuestGuide: html.includes('guest-guide'),
            hasUserFiles: html.includes('user_files'),
            totalImages: (html.match(/<img[^>]*>/g) || []).length,
            totalLinks: (html.match(/<a[^>]*href/g) || []).length
          },
          // ãƒ‘ã‚¿ãƒ¼ãƒ³ãƒãƒƒãƒãƒ³ã‚°çµæœ
          patterns: {
            modalGuestGuideLinks: (html.match(/\/modal\/guest-guide\/\d+/g) || []).length,
            liverDetailLinks: (html.match(/\/liver\/detail\/\d+/g) || []).length,
            userFilesThumbnail: (html.match(/\/user_files_thumbnail\/\d+/g) || []).length,
            liverNames: (html.match(/alt="[^"]*"/g) || []).slice(0, 5)
          },
          // HTMLã‚µãƒ³ãƒ—ãƒ«
          htmlSample: html.substring(0, 2000)
        };
        
        return new Response(JSON.stringify(analysis, null, 2), {
          headers: { 'Content-Type': 'application/json', ...corsHeaders }
        });
      } catch (error) {
        return new Response(JSON.stringify({ error: error.message }), {
          headers: { 'Content-Type': 'application/json', ...corsHeaders }
        });
      }
    }

    if (url.pathname === '/debug-html') {
      try {
        const listResponse = await fetch('https://www.comisapolive.com/liver/list/?q=&collaboration=&achievements=&rank=&app=&follower1=&follower2=&since=&gender=&age1=&age2=&regist=&search=1');
        const html = await listResponse.text();
        
        // HTMLã®è©³ç´°åˆ†æ
        const analysis = {
          htmlLength: html.length,
          containsPatterns: {
            detail: html.includes('detail'),
            liver: html.includes('liver'),
            id158: html.includes('158'),
            id155: html.includes('155'),
            href: html.includes('href='),
            user_files: html.includes('user_files')
          },
          // å…¨ã¦ã®hrefå±æ€§ã‚’æŠ½å‡ºï¼ˆæœ€åˆã®20å€‹ï¼‰
          allHrefs: Array.from(new Set(
            (html.match(/href="[^"]*"/g) || [])
              .map(h => h.replace(/href="([^"]*)"/, '$1'))
              .slice(0, 20)
          )),
          // ID 158ã‚’å«ã‚€éƒ¨åˆ†ã‚’æŠ½å‡º
          contains158Context: html.includes('158') ? 
            html.split('158').slice(0, 2).map((part, i) => 
              i === 0 ? part.slice(-150) + '***158***' : '***158***' + part.slice(0, 150)
            ) : [],
          // aã‚¿ã‚°ã®ã‚µãƒ³ãƒ—ãƒ«
          sampleATags: (html.match(/<a[^>]*>/g) || []).slice(0, 10),
          // å®Ÿéš›ã®ãƒ©ã‚¤ãƒãƒ¼åã‚’æ¢ã™
          liverNames: {
            aoi: html.includes('è’¼äº•ã¤ã‚€ã'),
            shion: html.includes('ã—ãŠã‚“'),
            himesaki: html.includes('å§«å’²')
          },
          // HTMLã®æ§‹é€ åˆ†æ
          structure: {
            hasImg: html.includes('<img'),
            hasDiv: html.includes('<div'),
            hasSpan: html.includes('<span'),
            imgCount: (html.match(/<img[^>]*>/g) || []).length,
            aTagCount: (html.match(/<a[^>]*>/g) || []).length
          }
        };
        
        return new Response(JSON.stringify(analysis, null, 2), {
          headers: { 'Content-Type': 'application/json', ...corsHeaders }
        });
      } catch (error) {
        return new Response(JSON.stringify({ error: error.message }), {
          headers: { 'Content-Type': 'application/json', ...corsHeaders }
        });
      }
    }

    if (url.pathname === '/debug-html-auth') {
      try {
        console.log('ğŸ” Starting authenticated HTML debug...');
        
        // ãƒ­ã‚°ã‚¤ãƒ³å‡¦ç†
        const loginResult = await performRobustLogin(env);
        
        if (!loginResult.success) {
          return new Response(JSON.stringify({ 
            error: 'Login failed', 
            loginError: loginResult.error 
          }), {
            headers: { 'Content-Type': 'application/json', ...corsHeaders }
          });
        }
        
        console.log('âœ… Login successful for debug');
        
        // èªè¨¼ä»˜ãã§ä¸€è¦§ãƒšãƒ¼ã‚¸ã‚’å–å¾—
        const listResponse = await fetch('https://www.comisapolive.com/liver/list/?q=&collaboration=&achievements=&rank=&app=&follower1=&follower2=&since=&gender=&age1=&age2=&regist=&search=1', {
          headers: {
            'Cookie': loginResult.cookies,
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36',
            'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8',
            'Accept-Language': 'ja,en-US;q=0.9,en;q=0.8',
            'Referer': 'https://www.comisapolive.com/'
          }
        });
        
        console.log('ğŸ“„ List page response status:', listResponse.status);
        
        const html = await listResponse.text();
        
        const analysis = {
          loginSuccess: loginResult.success,
          responseStatus: listResponse.status,
          responseUrl: listResponse.url,
          htmlLength: html.length,
          containsPatterns: {
            detail: html.includes('detail'),
            liver: html.includes('liver'),
            id158: html.includes('158'),
            user_files: html.includes('user_files'),
            login: html.includes('ãƒ­ã‚°ã‚¤ãƒ³')
          },
          // è©³ç´°ãƒªãƒ³ã‚¯ãƒ‘ã‚¿ãƒ¼ãƒ³ã®æ¤œç´¢
          linkPatterns: {
            liver_detail: (html.match(/liver\/detail/g) || []).length,
            href_detail: (html.match(/href="[^"]*detail[^"]*"/g) || []).slice(0, 5),
            any_158: (html.match(/158/g) || []).length
          },
          // HTMLã®æœ€åˆã®éƒ¨åˆ†ã‚’ç¢ºèª
          htmlStart: html.substring(0, 1000),
          // Cookieã®ç¢ºèª
          cookiesUsed: loginResult.cookies.length > 0
        };
        
        return new Response(JSON.stringify(analysis, null, 2), {
          headers: { 'Content-Type': 'application/json', ...corsHeaders }
        });
      } catch (error) {
        return new Response(JSON.stringify({ 
          error: error.message,
          stack: error.stack 
        }), {
          headers: { 'Content-Type': 'application/json', ...corsHeaders }
        });
      }
    }

    if (url.pathname === '/debug-html-detailed') {
      try {
        const loginResult = await performRobustLogin(env);
        if (!loginResult.success) {
          return new Response(JSON.stringify({ error: 'Login failed' }), {
            headers: { 'Content-Type': 'application/json', ...corsHeaders }
          });
        }
        
        const listResponse = await fetch('https://www.comisapolive.com/liver/list/?q=&collaboration=&achievements=&rank=&app=&follower1=&follower2=&since=&gender=&age1=&age2=&regist=&search=1', {
          headers: {
            'Cookie': loginResult.cookies,
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36',
            'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8',
            'Accept-Language': 'ja,en-US;q=0.9,en;q=0.8',
            'Referer': 'https://www.comisapolive.com/'
          }
        });
        
        const html = await listResponse.text();
        
        // ã‚ˆã‚Šè©³ç´°ãªåˆ†æ
        const analysis = {
          // ID158å‘¨è¾ºã®ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆ
          id158Contexts: html.split('158').slice(0, 3).map((part, i) => 
            i === 0 ? part.slice(-200) + '***158***' : '***158***' + part.slice(0, 200)
          ),
          
          // å…¨ã¦ã®aã‚¿ã‚°ï¼ˆhrefå«ã‚€ï¼‰
          allATags: (html.match(/<a[^>]*href="[^"]*"[^>]*>/g) || []).slice(0, 15),
          
          // è’¼äº•ã¤ã‚€ãå‘¨è¾ºã®HTML
          aoiContext: html.includes('è’¼äº•ã¤ã‚€ã') ? 
            html.split('è’¼äº•ã¤ã‚€ã').slice(0, 2).map((part, i) => 
              i === 0 ? part.slice(-300) + '***è’¼äº•ã¤ã‚€ã***' : '***è’¼äº•ã¤ã‚€ã***' + part.slice(0, 300)
            ) : ['Not found'],
          
          // å¯èƒ½æ€§ã®ã‚ã‚‹ãƒªãƒ³ã‚¯ãƒ‘ã‚¿ãƒ¼ãƒ³
          possibleLinkPatterns: {
            profile: (html.match(/href="[^"]*profile[^"]*"/g) || []).slice(0, 5),
            user: (html.match(/href="[^"]*user[^"]*"/g) || []).slice(0, 5),
            show: (html.match(/href="[^"]*show[^"]*"/g) || []).slice(0, 5),
            view: (html.match(/href="[^"]*view[^"]*"/g) || []).slice(0, 5),
            id_pattern: (html.match(/href="[^"]*\/\d+[^"]*"/g) || []).slice(0, 10)
          },
          
          // å®Ÿéš›ã®ãƒ©ã‚¤ãƒãƒ¼æƒ…å ±ã®æ§‹é€ 
          liverStructure: {
            hasUserFiles: html.includes('user_files'),
            userFilesCount: (html.match(/user_files/g) || []).length,
            imgTagsCount: (html.match(/<img[^>]*>/g) || []).length,
            // user_files ã‚’å«ã‚€img ã‚¿ã‚°
            userFilesImgs: (html.match(/<img[^>]*user_files[^>]*>/g) || []).slice(0, 5)
          }
        };
        
        return new Response(JSON.stringify(analysis, null, 2), {
          headers: { 'Content-Type': 'application/json', ...corsHeaders }
        });
      } catch (error) {
        return new Response(JSON.stringify({ error: error.message }), {
          headers: { 'Content-Type': 'application/json', ...corsHeaders }
        });
      }
    }

    if (url.pathname === '/debug-detail-url') {
      try {
        const loginResult = await performRobustLogin(env);
        if (!loginResult.success) {
          return new Response(JSON.stringify({ error: 'Login failed' }), {
            headers: { 'Content-Type': 'application/json', ...corsHeaders }
          });
        }
        
        // è¤‡æ•°ã®è©³ç´°ãƒšãƒ¼ã‚¸URLãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’è©¦è¡Œ
        const testUrls = [
          'https://www.comisapolive.com/liver/detail/158/',
          'https://www.comisapolive.com/liver/158/',
          'https://www.comisapolive.com/profile/158/',
          'https://www.comisapolive.com/user/158/',
          'https://www.comisapolive.com/modal/guest-guide/158'
        ];
        
        const results = {};
        
        for (const url of testUrls) {
          try {
            const response = await fetch(url, {
              headers: {
                'Cookie': loginResult.cookies,
                'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36',
                'Referer': 'https://www.comisapolive.com/'
              }
            });
            
            const html = await response.text();
            
            results[url] = {
              status: response.status,
              url: response.url,
              htmlLength: html.length,
              requiresLogin: html.includes('ãƒ­ã‚°ã‚¤ãƒ³') || response.url.includes('login'),
              hasProfile: html.includes('liverProf_') || html.includes('profile'),
              hasGender: html.includes('æ€§åˆ¥'),
              htmlPreview: html.substring(0, 200)
            };
          } catch (error) {
            results[url] = { error: error.message };
          }
        }
        
        return new Response(JSON.stringify(results, null, 2), {
          headers: { 'Content-Type': 'application/json', ...corsHeaders }
        });
      } catch (error) {
        return new Response(JSON.stringify({ error: error.message }), {
          headers: { 'Content-Type': 'application/json', ...corsHeaders }
        });
      }
    }

    if (url.pathname === '/debug-cookies') {
      try {
        const loginResult = await performRobustLogin(env);
        
        if (!loginResult.success) {
          return new Response(JSON.stringify({ error: 'Login failed' }), {
            headers: { 'Content-Type': 'application/json', ...corsHeaders }
          });
        }
        
        console.log('ğŸª Cookies being used:', loginResult.cookies);
        
        // è©³ç´°ãƒšãƒ¼ã‚¸ã«ã‚¢ã‚¯ã‚»ã‚¹ã—ã¦ãƒ¬ã‚¹ãƒãƒ³ã‚¹ãƒ˜ãƒƒãƒ€ãƒ¼ã‚’ç¢ºèª
        const detailResponse = await fetch('https://www.comisapolive.com/liver/detail/158/', {
          headers: {
            'Cookie': loginResult.cookies,
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36',
            'Referer': 'https://www.comisapolive.com/',
            'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8'
          }
        });
        
        const cookieAnalysis = {
          loginCookies: loginResult.cookies,
          detailResponseStatus: detailResponse.status,
          detailResponseUrl: detailResponse.url,
          detailResponseHeaders: Object.fromEntries(detailResponse.headers.entries()),
          cookieLength: loginResult.cookies.length,
          cookiePreview: loginResult.cookies.substring(0, 200)
        };
        
        return new Response(JSON.stringify(cookieAnalysis, null, 2), {
          headers: { 'Content-Type': 'application/json', ...corsHeaders }
        });
      } catch (error) {
        return new Response(JSON.stringify({ error: error.message }), {
          headers: { 'Content-Type': 'application/json', ...corsHeaders }
        });
      }
    }

    if (url.pathname === '/debug-detail-content') {
      try {
        const loginResult = await performRobustLogin(env);
        if (!loginResult.success) {
          return new Response(JSON.stringify({ error: 'Login failed' }), {
            headers: { 'Content-Type': 'application/json', ...corsHeaders }
          });
        }
        
        const detailResponse = await fetch('https://www.comisapolive.com/liver/detail/158/', {
          headers: {
            'Cookie': loginResult.cookies,
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36',
            'Referer': 'https://www.comisapolive.com/',
            'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8'
          }
        });
        
        const html = await detailResponse.text();
        
        const analysis = {
          status: detailResponse.status,
          url: detailResponse.url,
          htmlLength: html.length,
          containsProfile: {
            liverProf_tag: html.includes('liverProf_tag'),
            liverProf_name: html.includes('liverProf_name'),
            liverProf_prof: html.includes('liverProf_prof'),
            gender_text: html.includes('æ€§åˆ¥'),
            male_female: html.includes('ç”·æ€§') || html.includes('å¥³æ€§')
          },
          profileClasses: {
            categories: (html.match(/liverProf_tag[^>]*>([^<]*)</g) || []).slice(0, 3),
            names: (html.match(/liverProf_name[^>]*>([^<]*)</g) || []).slice(0, 3),
            profiles: (html.match(/liverProf_prof[^>]*>([^<]*)</g) || []).slice(0, 3)
          },
          htmlPreview: html.substring(0, 1000)
        };
        
        return new Response(JSON.stringify(analysis, null, 2), {
          headers: { 'Content-Type': 'application/json', ...corsHeaders }
        });
      } catch (error) {
        return new Response(JSON.stringify({ error: error.message }), {
          headers: { 'Content-Type': 'application/json', ...corsHeaders }
        });
      }
    }

    if (url.pathname === '/batch-scrape') {
      try {
        const url_params = new URL(request.url);
        const batchSize = parseInt(url_params.searchParams.get('batch') || '5');
        const startIndex = parseInt(url_params.searchParams.get('start') || '0');
        
        console.log(`ğŸš€ Batch scraping started (batch: ${batchSize}, start: ${startIndex})`);
        
        // ãƒ­ã‚°ã‚¤ãƒ³å‡¦ç†
        const loginResult = await performRobustLogin(env);
        if (!loginResult.success) {
          throw new Error(`Login failed: ${loginResult.error}`);
        }
        
        // åŸºæœ¬ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—
        const listResponse = await fetch('https://www.comisapolive.com/liver/list/?q=&collaboration=&achievements=&rank=&app=&follower1=&follower2=&since=&gender=&age1=&age2=&regist=&search=1', {
          headers: {
            'Cookie': loginResult.cookies,
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36',
            'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8',
            'Accept-Language': 'ja,en-US;q=0.9,en;q=0.8',
            'Referer': 'https://www.comisapolive.com/'
          }
        });
        
        const html = await listResponse.text();
        const pageData = await parseHTMLPageWithDetails(html, env, 1);
        
        console.log(`ğŸ“Š Found ${pageData.length} livers, processing batch ${startIndex}-${startIndex + batchSize}`);
        
        // ãƒãƒƒãƒå‡¦ç†: æŒ‡å®šã•ã‚ŒãŸç¯„å›²ã®ã¿è©³ç´°å–å¾—
        const batchData = pageData.slice(startIndex, startIndex + batchSize);
        const processedData = [];
        
        for (const liver of batchData) {
          if (liver.detailUrl) {
            console.log(`ğŸ” Processing: ${liver.name}`);
            const detailInfo = await scrapeDetailPageWithAuth(liver.detailUrl, loginResult.cookies, env);
            Object.assign(liver, detailInfo);
            
            if (detailInfo.profileInfo && detailInfo.profileInfo.gender) {
              console.log(`ğŸ‘¤ Gender found for ${liver.name}: ${detailInfo.profileInfo.gender}`);
            }
            
            processedData.push(liver);
            await sleep(500); // è² è·è»½æ¸›
          }
        }
        
        // æ—¢å­˜ãƒ‡ãƒ¼ã‚¿ã¨çµåˆã—ã¦ä¿å­˜
        let allData = processedData;
        
        // æ—¢å­˜ãƒ‡ãƒ¼ã‚¿ãŒã‚ã‚Œã°çµåˆ
        const existingDataStr = env.LIVER_DATA ? await env.LIVER_DATA.get('latest_data') : null;
        if (existingDataStr) {
          const existingData = JSON.parse(existingDataStr);
          // é‡è¤‡ã‚’é™¤å»ã—ã¦çµåˆ
          const existingIds = new Set(existingData.data.map(l => l.originalId));
          const newData = processedData.filter(l => !existingIds.has(l.originalId));
          allData = [...existingData.data, ...newData];
        }
        
        // ä¿å­˜
        if (env.LIVER_DATA) {
          await env.LIVER_DATA.put('latest_data', JSON.stringify({
            timestamp: Date.now(),
            total: allData.length,
            data: allData,
            lastUpdate: new Date().toISOString(),
            batchInfo: {
              lastBatch: `${startIndex}-${startIndex + batchSize}`,
              totalLivers: pageData.length,
              processed: allData.length
            }
          }));
        }
        
        return new Response(JSON.stringify({
          success: true,
          message: 'Batch processing completed',
          batchProcessed: processedData.length,
          totalStored: allData.length,
          totalAvailable: pageData.length,
          nextBatch: startIndex + batchSize < pageData.length ? startIndex + batchSize : null,
          nextUrl: startIndex + batchSize < pageData.length ? 
            `${request.url.split('?')[0]}?start=${startIndex + batchSize}&batch=${batchSize}` : null,
          sampleData: processedData.slice(0, 2)
        }, null, 2), {
          headers: { 'Content-Type': 'application/json', ...corsHeaders }
        });
        
      } catch (error) {
        console.error('âŒ Batch scraping failed:', error);
        return new Response(JSON.stringify({
          success: false,
          error: error.message
        }), {
          status: 500,
          headers: { 'Content-Type': 'application/json', ...corsHeaders }
        });
      }
    }

    // 2. è‡ªå‹•ãƒãƒƒãƒå‡¦ç†ã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆ
    if (url.pathname === '/auto-batch') {
      try {
        // ç¾åœ¨ã®çŠ¶æ³ã‚’ç¢ºèª
        const statusResponse = await fetch(`${request.url.replace('/auto-batch', '/scrape-status')}`);
        const status = await statusResponse.json();
        
        let startIndex = 0;
        if (status.hasData && status.sampleLivers) {
          // æ—¢å­˜ãƒ‡ãƒ¼ã‚¿ãŒã‚ã‚‹å ´åˆã¯ç¶šãã‹ã‚‰
          startIndex = status.totalLivers || 0;
        }
        
        // æœ€åˆã®ãƒãƒƒãƒã‚’å®Ÿè¡Œ
        const batchResponse = await fetch(`${request.url.replace('/auto-batch', '/batch-scrape')}?start=${startIndex}&batch=5`);
        const batchResult = await batchResponse.json();
        
        return new Response(JSON.stringify({
          message: 'Auto batch processing started',
          firstBatch: batchResult,
          instructions: {
            continue: batchResult.nextUrl ? `curl "${batchResult.nextUrl}"` : null,
            checkStatus: `curl "${request.url.replace('/auto-batch', '/scrape-status')}"`
          }
        }, null, 2), {
          headers: { 'Content-Type': 'application/json', ...corsHeaders }
        });
        
      } catch (error) {
        return new Response(JSON.stringify({
          error: error.message
        }), {
          status: 500,
          headers: { 'Content-Type': 'application/json', ...corsHeaders }
        });
      }
    }

    if (url.pathname === '/full-scrape') {
      try {
        const url_params = new URL(request.url);
        const maxPages = parseInt(url_params.searchParams.get('pages') || '50'); // æœ€å¤§ãƒšãƒ¼ã‚¸æ•°åˆ¶é™
        const batchSize = parseInt(url_params.searchParams.get('batch') || '10'); // 1ãƒšãƒ¼ã‚¸ã‚ãŸã‚Šã®ãƒãƒƒãƒã‚µã‚¤ã‚º
        
        console.log(`ğŸš€ Full scraping started (max pages: ${maxPages}, batch size: ${batchSize})`);
        
        // ãƒ­ã‚°ã‚¤ãƒ³å‡¦ç†
        const loginResult = await performRobustLogin(env);
        if (!loginResult.success) {
          throw new Error(`Login failed: ${loginResult.error}`);
        }
        
        let allLivers = [];
        let currentPage = 1;
        let totalPagesDetected = null;
        
        // å…¨ãƒšãƒ¼ã‚¸ã‚’ã‚¹ã‚¯ãƒ¬ã‚¤ãƒ”ãƒ³ã‚°
        while (currentPage <= maxPages) {
          console.log(`ğŸ“„ Processing page ${currentPage}...`);
          
          const pageUrl = currentPage === 1 
            ? 'https://www.comisapolive.com/liver/list/?q=&collaboration=&achievements=&rank=&app=&follower1=&follower2=&since=&gender=&age1=&age2=&regist=&search=1'
            : `https://www.comisapolive.com/liver/list/?q=&collaboration=&achievements=&rank=&app=&follower1=&follower2=&since=&gender=&age1=&age2=&regist=&search=1&page=${currentPage}`;
          
          // ãƒšãƒ¼ã‚¸ã‚’å–å¾—
          const pageResponse = await fetch(pageUrl, {
            headers: {
              'Cookie': loginResult.cookies,
              'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36',
              'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8',
              'Accept-Language': 'ja,en-US;q=0.9,en;q=0.8',
              'Referer': 'https://www.comisapolive.com/'
            }
          });
          
          if (!pageResponse.ok) {
            console.log(`âš ï¸ Page ${currentPage} failed with status ${pageResponse.status}`);
            break;
          }
          
          const html = await pageResponse.text();
          
          // æœ€åˆã®ãƒšãƒ¼ã‚¸ã§ç·ãƒšãƒ¼ã‚¸æ•°ã‚’æ¤œå‡º
          if (totalPagesDetected === null) {
            totalPagesDetected = getMaxPages(html);
            console.log(`ğŸ“Š Total pages detected: ${totalPagesDetected}`);
          }
          
          // ãƒšãƒ¼ã‚¸ãƒ‡ãƒ¼ã‚¿ã‚’è§£æ
          const pageData = await parseHTMLPageWithDetails(html, env, currentPage);
          
          if (pageData.length === 0) {
            console.log(`ğŸ“„ Page ${currentPage}: No data found, stopping`);
            break;
          }
          
          console.log(`ğŸ“„ Page ${currentPage}: Found ${pageData.length} livers`);
          
          // ãƒãƒƒãƒå‡¦ç†ã§è©³ç´°æƒ…å ±ã‚’å–å¾—
          let processedInPage = 0;
          for (let i = 0; i < pageData.length; i += batchSize) {
            const batch = pageData.slice(i, i + batchSize);
            console.log(`ğŸ”„ Processing page ${currentPage}, batch ${Math.floor(i/batchSize) + 1}/${Math.ceil(pageData.length/batchSize)}`);
            
            for (const liver of batch) {
              if (liver.detailUrl) {
                console.log(`ğŸ” Processing: ${liver.name} (Page ${currentPage})`);
                const detailInfo = await scrapeDetailPageWithAuth(liver.detailUrl, loginResult.cookies, env);
                Object.assign(liver, detailInfo);
                
                if (detailInfo.profileInfo && detailInfo.profileInfo.gender) {
                  console.log(`ğŸ‘¤ Gender found for ${liver.name}: ${detailInfo.profileInfo.gender}`);
                }
                
                processedInPage++;
                await sleep(300); // è² è·è»½æ¸›
              }
            }
            
            // ãƒãƒƒãƒé–“ã®ä¼‘æ†©
            if (i + batchSize < pageData.length) {
              await sleep(1000);
            }
          }
          
          allLivers = allLivers.concat(pageData);
          console.log(`âœ… Page ${currentPage} completed: ${processedInPage} livers processed (Total: ${allLivers.length})`);
          
          // æ¬¡ã®ãƒšãƒ¼ã‚¸ã¸
          currentPage++;
          
          // ãƒšãƒ¼ã‚¸é–“ã®ä¼‘æ†©
          if (currentPage <= (totalPagesDetected || maxPages)) {
            await sleep(2000);
          }
          
          // æ¤œå‡ºã•ã‚ŒãŸç·ãƒšãƒ¼ã‚¸æ•°ã«é”ã—ãŸã‚‰åœæ­¢
          if (totalPagesDetected && currentPage > totalPagesDetected) {
            console.log(`ğŸ“„ Reached detected max pages (${totalPagesDetected}), stopping`);
            break;
          }
        }
        
        console.log(`ğŸ‰ Full scraping completed: ${allLivers.length} total livers from ${currentPage - 1} pages`);
        
        // KVã«ä¿å­˜
        const finalData = {
          timestamp: Date.now(),
          total: allLivers.length,
          data: allLivers,
          lastUpdate: new Date().toISOString(),
          pagesProcessed: currentPage - 1,
          totalPagesDetected: totalPagesDetected
        };
        
        if (env.LIVER_DATA) {
          await env.LIVER_DATA.put('latest_data', JSON.stringify(finalData));
          console.log(`ğŸ’¾ Saved ${allLivers.length} livers to KV storage`);
        }
        
        return new Response(JSON.stringify({
          success: true,
          message: 'Full scraping completed',
          totalProcessed: allLivers.length,
          pagesProcessed: currentPage - 1,
          totalPagesDetected: totalPagesDetected,
          lastUpdate: finalData.lastUpdate,
          sampleData: allLivers.slice(0, 3),
          genderStats: {
            withGender: allLivers.filter(l => l.genderSearchResults?.bestMatch).length,
            total: allLivers.length
          }
        }, null, 2), {
          headers: { 'Content-Type': 'application/json', ...corsHeaders }
        });
        
      } catch (error) {
        console.error('âŒ Full scraping failed:', error);
        return new Response(JSON.stringify({
          success: false,
          error: error.message,
          stack: error.stack
        }), {
          status: 500,
          headers: { 'Content-Type': 'application/json', ...corsHeaders }
        });
      }
    }

    // ãƒ‡ãƒãƒƒã‚°ç”¨ï¼šãƒšãƒ¼ã‚¸æ•°ç¢ºèªã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆ
    if (url.pathname === '/check-pages') {
      try {
        const loginResult = await performRobustLogin(env);
        if (!loginResult.success) {
          throw new Error(`Login failed: ${loginResult.error}`);
        }
        
        const firstPageResponse = await fetch('https://www.comisapolive.com/liver/list/?q=&collaboration=&achievements=&rank=&app=&follower1=&follower2=&since=&gender=&age1=&age2=&regist=&search=1', {
          headers: {
            'Cookie': loginResult.cookies,
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36',
            'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8',
            'Accept-Language': 'ja,en-US;q=0.9,en;q=0.8',
            'Referer': 'https://www.comisapolive.com/'
          }
        });
        
        const html = await firstPageResponse.text();
        const maxPages = getMaxPages(html);
        const firstPageLivers = await parseHTMLPageWithDetails(html, env, 1);
        
        // ãƒšãƒ¼ã‚¸ãƒãƒ¼ã‚·ãƒ§ãƒ³æƒ…å ±ã‚’è©³ç´°ã«åˆ†æ
        const paginationInfo = {
          maxPagesDetected: maxPages,
          firstPageLivers: firstPageLivers.length,
          // ãƒšãƒ¼ã‚¸ãƒãƒ¼ã‚·ãƒ§ãƒ³ãƒªãƒ³ã‚¯ã‚’æ¢ã™
          pageLinks: (html.match(/[?&]page=(\d+)/g) || []).map(match => parseInt(match.split('=')[1])),
          // "æ¬¡ã¸"ãƒœã‚¿ãƒ³ã®æœ‰ç„¡
          hasNextButton: html.includes('æ¬¡ã¸') || html.includes('next') || html.includes('&gt;'),
          // ãƒšãƒ¼ã‚¸ç•ªå·ã®æœ€å¤§å€¤
          maxPageInLinks: Math.max(...((html.match(/[?&]page=(\d+)/g) || []).map(match => parseInt(match.split('=')[1])) || [1]))
        };
        
        return new Response(JSON.stringify({
          success: true,
          paginationInfo: paginationInfo,
          recommendation: {
            estimatedTotalPages: maxPages,
            estimatedTotalLivers: firstPageLivers.length * maxPages,
            shouldUseFullScrape: maxPages > 1
          }
        }, null, 2), {
          headers: { 'Content-Type': 'application/json', ...corsHeaders }
        });
        
      } catch (error) {
        return new Response(JSON.stringify({
          success: false,
          error: error.message
        }), {
          status: 500,
          headers: { 'Content-Type': 'application/json', ...corsHeaders }
        });
      }
    }

    if (url.pathname === '/analyze-pagination') {
      try {
        const loginResult = await performRobustLogin(env);
        if (!loginResult.success) {
          throw new Error(`Login failed: ${loginResult.error}`);
        }
        
        const firstPageResponse = await fetch('https://www.comisapolive.com/liver/list/?q=&collaboration=&achievements=&rank=&app=&follower1=&follower2=&since=&gender=&age1=&age2=&regist=&search=1', {
          headers: {
            'Cookie': loginResult.cookies,
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36',
            'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8',
            'Accept-Language': 'ja,en-US;q=0.9,en;q=0.8',
            'Referer': 'https://www.comisapolive.com/'
          }
        });
        
        const html = await firstPageResponse.text();
        
        // ã‚ˆã‚Šè©³ç´°ãªãƒšãƒ¼ã‚¸ãƒãƒ¼ã‚·ãƒ§ãƒ³åˆ†æ
        const analysis = {
          htmlLength: html.length,
          
          // å…¨ã¦ã®ãƒšãƒ¼ã‚¸é–¢é€£ã®ãƒªãƒ³ã‚¯ã‚’æŠ½å‡º
          allPageLinks: (html.match(/href="[^"]*[?&]page=\d+[^"]*"/g) || [])
            .map(link => link.match(/page=(\d+)/)?.[1])
            .filter(Boolean)
            .map(Number),
          
          // ãƒšãƒ¼ã‚¸ãƒãƒ¼ã‚·ãƒ§ãƒ³é–¢é€£ã®HTMLãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’æ¤œç´¢
          paginationPatterns: {
            hasPageClass: html.includes('page'),
            hasPaginationClass: html.includes('pagination'),
            hasNextLink: html.includes('æ¬¡ã¸') || html.includes('next') || html.includes('&gt;'),
            hasPrevLink: html.includes('å‰ã¸') || html.includes('prev') || html.includes('&lt;'),
            pageParameterCount: (html.match(/[?&]page=/g) || []).length
          },
          
          // æ•°å­—ã®ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’æ¤œç´¢ï¼ˆãƒšãƒ¼ã‚¸ç•ªå·ã®å¯èƒ½æ€§ï¼‰
          numberPatterns: {
            numbersInLinks: (html.match(/>\s*(\d+)\s*</g) || [])
              .map(match => match.match(/(\d+)/)?.[1])
              .filter(n => n && parseInt(n) > 1 && parseInt(n) < 100)
              .slice(0, 10),
            
            // ãƒšãƒ¼ã‚¸é–¢é€£ã®æ–‡å­—åˆ—ã‚’æ¤œç´¢
            pageStrings: html.match(/page[^>]*>.*?</gi)?.slice(0, 5) || []
          },
          
          // ãƒ•ã‚©ãƒ¼ãƒ è¦ç´ ã®ç¢ºèª
          forms: {
            hasForm: html.includes('<form'),
            hasPageInput: html.includes('name="page"') || html.includes('id="page"'),
            hasSearchForm: html.includes('search=1')
          },
          
          // HTMLã®æ§‹é€ åˆ†æ
          structure: {
            totalLinks: (html.match(/<a[^>]*href/g) || []).length,
            hasFooter: html.includes('footer'),
            hasNav: html.includes('nav'),
            liverItemCount: (html.match(/livers_item/g) || []).length
          }
        };
        
        // 2ãƒšãƒ¼ã‚¸ç›®ãŒå­˜åœ¨ã™ã‚‹ã‹ãƒ†ã‚¹ãƒˆ
        let page2Test = null;
        try {
          const page2Response = await fetch('https://www.comisapolive.com/liver/list/?q=&collaboration=&achievements=&rank=&app=&follower1=&follower2=&since=&gender=&age1=&age2=&regist=&search=1&page=2', {
            headers: {
              'Cookie': loginResult.cookies,
              'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36',
              'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8',
              'Accept-Language': 'ja,en-US;q=0.9,en;q=0.8',
              'Referer': 'https://www.comisapolive.com/'
            }
          });
          
          const page2Html = await page2Response.text();
          const page2Livers = await parseHTMLPageWithDetails(page2Html, env, 2);
          
          page2Test = {
            status: page2Response.status,
            url: page2Response.url,
            htmlLength: page2Html.length,
            liverCount: page2Livers.length,
            differentFromPage1: page2Html !== html,
            hasLivers: page2Livers.length > 0,
            sampleLiverNames: page2Livers.slice(0, 3).map(l => l.name)
          };
        } catch (page2Error) {
          page2Test = { error: page2Error.message };
        }
        
        return new Response(JSON.stringify({
          success: true,
          analysis: analysis,
          page2Test: page2Test,
          recommendations: {
            likelyHasMultiplePages: !!(page2Test?.hasLivers),
            shouldTrySequentialPages: true,
            maxPagesToTry: page2Test?.hasLivers ? 10 : 1
          }
        }, null, 2), {
          headers: { 'Content-Type': 'application/json', ...corsHeaders }
        });
        
      } catch (error) {
        return new Response(JSON.stringify({
          success: false,
          error: error.message
        }), {
          status: 500,
          headers: { 'Content-Type': 'application/json', ...corsHeaders }
        });
      }
    }

    // å¼·åŒ–ã•ã‚ŒãŸgetMaxPagesé–¢æ•°
    function getMaxPagesEnhanced(html) {
      let maxPage = 1;
      
      // æ–¹æ³•1: æ—¢å­˜ã®ãƒšãƒ¼ã‚¸ãƒªãƒ³ã‚¯ãƒ‘ã‚¿ãƒ¼ãƒ³
      const pagePattern = /[?&]page=(\d+)/g;
      let match;
      while ((match = pagePattern.exec(html)) !== null) {
        const pageNum = parseInt(match[1]);
        if (pageNum > maxPage && pageNum < 1000) { // ç¾å®Ÿçš„ãªä¸Šé™
          maxPage = pageNum;
        }
      }
      
      // æ–¹æ³•2: ãƒšãƒ¼ã‚¸ãƒãƒ¼ã‚·ãƒ§ãƒ³å†…ã®æ•°å­—ã‚’æ¤œç´¢
      const paginationPattern = /<nav[^>]*>[\s\S]*?<\/nav>|<div[^>]*pagination[^>]*>[\s\S]*?<\/div>/gi;
      let paginationMatch;
      while ((paginationMatch = paginationPattern.exec(html)) !== null) {
        const paginationHtml = paginationMatch[0];
        const numbersInPagination = paginationHtml.match(/>\s*(\d+)\s*</g);
        if (numbersInPagination) {
          numbersInPagination.forEach(numMatch => {
            const num = parseInt(numMatch.match(/(\d+)/)[1]);
            if (num > maxPage && num < 100) {
              maxPage = num;
            }
          });
        }
      }
      
      // æ–¹æ³•3: ã€Œæ¬¡ã¸ã€ãƒœã‚¿ãƒ³ãŒã‚ã‚‹å ´åˆã¯æœ€ä½2ãƒšãƒ¼ã‚¸ä»¥ä¸Š
      if (maxPage === 1 && (html.includes('æ¬¡ã¸') || html.includes('next') || html.includes('&gt;'))) {
        maxPage = 2; // æœ€ä½2ãƒšãƒ¼ã‚¸ã¯ã‚ã‚‹ã¨æ¨å®š
      }
      
      return maxPage;
    }

    if (url.pathname === '/force-multi-scrape') {
      try {
        const url_params = new URL(request.url);
        const maxPages = parseInt(url_params.searchParams.get('pages') || '20');
        const batchSize = parseInt(url_params.searchParams.get('batch') || '8');
        
        console.log(`ğŸš€ Force multi-page scraping started (max pages: ${maxPages}, batch size: ${batchSize})`);
        
        // ãƒ­ã‚°ã‚¤ãƒ³å‡¦ç†
        const loginResult = await performRobustLogin(env);
        if (!loginResult.success) {
          throw new Error(`Login failed: ${loginResult.error}`);
        }
        
        let allLivers = [];
        let currentPage = 1;
        let consecutiveEmptyPages = 0;
        
        // å¼·åˆ¶çš„ã«æŒ‡å®šã•ã‚ŒãŸãƒšãƒ¼ã‚¸æ•°ã¾ã§è©¦è¡Œ
        while (currentPage <= maxPages && consecutiveEmptyPages < 3) {
          console.log(`ğŸ“„ Force processing page ${currentPage}...`);
          
          const pageUrl = currentPage === 1 
            ? 'https://www.comisapolive.com/liver/list/?q=&collaboration=&achievements=&rank=&app=&follower1=&follower2=&since=&gender=&age1=&age2=&regist=&search=1'
            : `https://www.comisapolive.com/liver/list/?q=&collaboration=&achievements=&rank=&app=&follower1=&follower2=&since=&gender=&age1=&age2=&regist=&search=1&page=${currentPage}`;
          
          // ãƒšãƒ¼ã‚¸ã‚’å–å¾—
          const pageResponse = await fetch(pageUrl, {
            headers: {
              'Cookie': loginResult.cookies,
              'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36',
              'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8',
              'Accept-Language': 'ja,en-US;q=0.9,en;q=0.8',
              'Referer': currentPage === 1 ? 'https://www.comisapolive.com/' : `https://www.comisapolive.com/liver/list/?page=${currentPage-1}`
            }
          });
          
          console.log(`ğŸ“„ Page ${currentPage} response: ${pageResponse.status} -> ${pageResponse.url}`);
          
          if (!pageResponse.ok) {
            console.log(`âš ï¸ Page ${currentPage} failed with status ${pageResponse.status}`);
            consecutiveEmptyPages++;
            currentPage++;
            continue;
          }
          
          const html = await pageResponse.text();
          
          // ãƒšãƒ¼ã‚¸ãƒ‡ãƒ¼ã‚¿ã‚’è§£æ
          const pageData = await parseHTMLPageWithDetails(html, env, currentPage);
          
          if (pageData.length === 0) {
            console.log(`ğŸ“„ Page ${currentPage}: No data found`);
            consecutiveEmptyPages++;
            currentPage++;
            continue;
          }
          
          console.log(`ğŸ“„ Page ${currentPage}: Found ${pageData.length} livers`);
          consecutiveEmptyPages = 0; // ãƒªã‚»ãƒƒãƒˆ
          
          // ãƒãƒƒãƒå‡¦ç†ã§è©³ç´°æƒ…å ±ã‚’å–å¾—
          let processedInPage = 0;
          for (let i = 0; i < pageData.length; i += batchSize) {
            const batch = pageData.slice(i, i + batchSize);
            const batchNum = Math.floor(i/batchSize) + 1;
            const totalBatches = Math.ceil(pageData.length/batchSize);
            
            console.log(`ğŸ”„ Processing page ${currentPage}, batch ${batchNum}/${totalBatches} (${batch.length} livers)`);
            
            for (const liver of batch) {
              if (liver.detailUrl) {
                console.log(`ğŸ” Processing: ${liver.name} (Page ${currentPage})`);
                try {
                  const detailInfo = await scrapeDetailPageWithAuth(liver.detailUrl, loginResult.cookies, env);
                  Object.assign(liver, detailInfo);
                  
                  if (detailInfo.profileInfo && detailInfo.profileInfo.gender) {
                    console.log(`ğŸ‘¤ Gender found for ${liver.name}: ${detailInfo.profileInfo.gender}`);
                  }
                  
                  processedInPage++;
                } catch (detailError) {
                  console.error(`âŒ Failed to process ${liver.name}:`, detailError.message);
                }
                
                await sleep(300); // è² è·è»½æ¸›
              }
            }
            
            // ãƒãƒƒãƒé–“ã®ä¼‘æ†©
            if (i + batchSize < pageData.length) {
              console.log(`â³ Batch break (3 seconds)...`);
              await sleep(3000);
            }
          }
          
          allLivers = allLivers.concat(pageData);
          console.log(`âœ… Page ${currentPage} completed: ${processedInPage} livers processed (Total so far: ${allLivers.length})`);
          
          // æ¬¡ã®ãƒšãƒ¼ã‚¸ã¸
          currentPage++;
          
          // ãƒšãƒ¼ã‚¸é–“ã®ä¼‘æ†©
          if (currentPage <= maxPages) {
            console.log(`â³ Page break (5 seconds)...`);
            await sleep(5000);
          }
        }
        
        const actualPagesProcessed = currentPage - 1;
        console.log(`ğŸ‰ Force multi-page scraping completed: ${allLivers.length} total livers from ${actualPagesProcessed} pages`);
        
        // KVã«ä¿å­˜
        const finalData = {
          timestamp: Date.now(),
          total: allLivers.length,
          data: allLivers,
          lastUpdate: new Date().toISOString(),
          pagesProcessed: actualPagesProcessed,
          maxPagesAttempted: maxPages,
          method: 'force_multi_page'
        };
        
        if (env.LIVER_DATA) {
          await env.LIVER_DATA.put('latest_data', JSON.stringify(finalData));
          console.log(`ğŸ’¾ Saved ${allLivers.length} livers to KV storage`);
        }
        
        return new Response(JSON.stringify({
          success: true,
          message: 'Force multi-page scraping completed',
          totalProcessed: allLivers.length,
          pagesProcessed: actualPagesProcessed,
          maxPagesAttempted: maxPages,
          lastUpdate: finalData.lastUpdate,
          sampleData: allLivers.slice(0, 3),
          genderStats: {
            withGender: allLivers.filter(l => l.genderSearchResults?.bestMatch).length,
            total: allLivers.length
          },
          pageBreakdown: allLivers.reduce((acc, liver) => {
            acc[`page_${liver.page}`] = (acc[`page_${liver.page}`] || 0) + 1;
            return acc;
          }, {})
        }, null, 2), {
          headers: { 'Content-Type': 'application/json', ...corsHeaders }
        });
        
      } catch (error) {
        console.error('âŒ Force multi-page scraping failed:', error);
        return new Response(JSON.stringify({
          success: false,
          error: error.message,
          stack: error.stack
        }), {
          status: 500,
          headers: { 'Content-Type': 'application/json', ...corsHeaders }
        });
      }
    }

    if (url.pathname === '/light-scrape') {
      try {
        const url_params = new URL(request.url);
        const maxPages = parseInt(url_params.searchParams.get('pages') || '10');
        const detailsPerPage = parseInt(url_params.searchParams.get('details') || '3'); // è©³ç´°å–å¾—æ•°ã‚’åˆ¶é™
        
        console.log(`ğŸš€ Light scraping started (max pages: ${maxPages}, details per page: ${detailsPerPage})`);
        
        // ãƒ­ã‚°ã‚¤ãƒ³å‡¦ç†
        const loginResult = await performRobustLogin(env);
        if (!loginResult.success) {
          throw new Error(`Login failed: ${loginResult.error}`);
        }
        
        let allLivers = [];
        let currentPage = 1;
        let consecutiveEmptyPages = 0;
        let totalSubrequests = 1; // ãƒ­ã‚°ã‚¤ãƒ³ã§1å›ä½¿ç”¨æ¸ˆã¿
        
        // è»½é‡ç‰ˆ: subrequeståˆ¶é™ã‚’è€ƒæ…®ã—ã¦å‡¦ç†
        while (currentPage <= maxPages && consecutiveEmptyPages < 3 && totalSubrequests < 45) {
          console.log(`ğŸ“„ Light processing page ${currentPage}... (subrequests used: ${totalSubrequests})`);
          
          const pageUrl = currentPage === 1 
            ? 'https://www.comisapolive.com/liver/list/?q=&collaboration=&achievements=&rank=&app=&follower1=&follower2=&since=&gender=&age1=&age2=&regist=&search=1'
            : `https://www.comisapolive.com/liver/list/?q=&collaboration=&achievements=&rank=&app=&follower1=&follower2=&since=&gender=&age1=&age2=&regist=&search=1&page=${currentPage}`;
          
          // ãƒšãƒ¼ã‚¸ã‚’å–å¾—
          const pageResponse = await fetch(pageUrl, {
            headers: {
              'Cookie': loginResult.cookies,
              'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36',
              'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8',
              'Accept-Language': 'ja,en-US;q=0.9,en;q=0.8',
              'Referer': currentPage === 1 ? 'https://www.comisapolive.com/' : `https://www.comisapolive.com/liver/list/?page=${currentPage-1}`
            }
          });
          
          totalSubrequests++; // ãƒšãƒ¼ã‚¸å–å¾—ã§1å›
          console.log(`ğŸ“„ Page ${currentPage} response: ${pageResponse.status} (subrequests: ${totalSubrequests})`);
          
          if (!pageResponse.ok) {
            console.log(`âš ï¸ Page ${currentPage} failed with status ${pageResponse.status}`);
            consecutiveEmptyPages++;
            currentPage++;
            continue;
          }
          
          const html = await pageResponse.text();
          
          // ãƒšãƒ¼ã‚¸ãƒ‡ãƒ¼ã‚¿ã‚’è§£æï¼ˆè©³ç´°å–å¾—ãªã—ï¼‰
          const pageData = await parseHTMLPageWithDetails(html, env, currentPage);
          
          if (pageData.length === 0) {
            console.log(`ğŸ“„ Page ${currentPage}: No data found`);
            consecutiveEmptyPages++;
            currentPage++;
            continue;
          }
          
          console.log(`ğŸ“„ Page ${currentPage}: Found ${pageData.length} livers`);
          consecutiveEmptyPages = 0;
          
          // ğŸ”§ åˆ¶é™ä»˜ãè©³ç´°å–å¾—: ãƒšãƒ¼ã‚¸ã‚ãŸã‚Šæœ€å¤§Näººã¾ã§
          let processedInPage = 0;
          for (let i = 0; i < Math.min(pageData.length, detailsPerPage) && totalSubrequests < 45; i++) {
            const liver = pageData[i];
            
            if (liver.detailUrl) {
              console.log(`ğŸ” Processing: ${liver.name} (Page ${currentPage}) - subrequest ${totalSubrequests + 1}`);
              
              try {
                const detailInfo = await scrapeDetailPageWithAuth(liver.detailUrl, loginResult.cookies, env);
                totalSubrequests++; // è©³ç´°ãƒšãƒ¼ã‚¸å–å¾—ã§1å›
                
                Object.assign(liver, detailInfo);
                
                if (detailInfo.profileInfo && detailInfo.profileInfo.gender) {
                  console.log(`ğŸ‘¤ Gender found for ${liver.name}: ${detailInfo.profileInfo.gender}`);
                }
                
                processedInPage++;
                await sleep(200); // çŸ­ã„ä¼‘æ†©
                
              } catch (detailError) {
                console.error(`âŒ Failed to process ${liver.name}:`, detailError.message);
                totalSubrequests++; // ã‚¨ãƒ©ãƒ¼ã§ã‚‚ã‚«ã‚¦ãƒ³ãƒˆ
              }
            }
          }
          
          // æ®‹ã‚Šã®ãƒ©ã‚¤ãƒãƒ¼ã«ã¯åŸºæœ¬æƒ…å ±ã®ã¿è¨­å®š
          for (let i = detailsPerPage; i < pageData.length; i++) {
            const liver = pageData[i];
            liver.detailStatus = 'basic_only'; // è©³ç´°æœªå–å¾—ãƒãƒ¼ã‚¯
          }
          
          allLivers = allLivers.concat(pageData);
          console.log(`âœ… Page ${currentPage} completed: ${processedInPage}/${pageData.length} detailed, ${pageData.length} total (Running total: ${allLivers.length})`);
          
          currentPage++;
          
          // subrequeståˆ¶é™ãƒã‚§ãƒƒã‚¯
          if (totalSubrequests >= 45) {
            console.log(`âš ï¸ Approaching subrequest limit (${totalSubrequests}/50), stopping early`);
            break;
          }
          
          // çŸ­ã„ä¼‘æ†©
          await sleep(1000);
        }
        
        const actualPagesProcessed = currentPage - 1;
        const detailedCount = allLivers.filter(l => !l.detailStatus).length;
        
        console.log(`ğŸ‰ Light scraping completed: ${allLivers.length} total livers (${detailedCount} with details) from ${actualPagesProcessed} pages`);
        
        // KVã«ä¿å­˜
        const finalData = {
          timestamp: Date.now(),
          total: allLivers.length,
          data: allLivers,
          lastUpdate: new Date().toISOString(),
          pagesProcessed: actualPagesProcessed,
          maxPagesAttempted: maxPages,
          subrequestsUsed: totalSubrequests,
          method: 'light_scraping',
          stats: {
            withDetails: detailedCount,
            basicOnly: allLivers.length - detailedCount
          }
        };
        
        if (env.LIVER_DATA) {
          await env.LIVER_DATA.put('latest_data', JSON.stringify(finalData));
          console.log(`ğŸ’¾ Saved ${allLivers.length} livers to KV storage`);
        }
        
        return new Response(JSON.stringify({
          success: true,
          message: 'Light scraping completed',
          totalProcessed: allLivers.length,
          withDetails: detailedCount,
          basicOnly: allLivers.length - detailedCount,
          pagesProcessed: actualPagesProcessed,
          subrequestsUsed: totalSubrequests,
          lastUpdate: finalData.lastUpdate,
          sampleData: allLivers.slice(0, 3),
          pageBreakdown: allLivers.reduce((acc, liver) => {
            const key = `page_${liver.page}`;
            if (!acc[key]) acc[key] = { total: 0, detailed: 0 };
            acc[key].total++;
            if (!liver.detailStatus) acc[key].detailed++;
            return acc;
          }, {}),
          recommendations: {
            continueWith: totalSubrequests >= 45 ? 
              `curl "${new URL(request.url).origin}/light-scrape?pages=${maxPages}&details=${detailsPerPage}"` : null,
            increaseDetails: detailedCount < allLivers.length ? 
              `curl "${new URL(request.url).origin}/detail-fill"` : null
          }
        }, null, 2), {
          headers: { 'Content-Type': 'application/json', ...corsHeaders }
        });
        
      } catch (error) {
        console.error('âŒ Light scraping failed:', error);
        return new Response(JSON.stringify({
          success: false,
          error: error.message,
          suggestion: "Try reducing pages or details parameters"
        }), {
          status: 500,
          headers: { 'Content-Type': 'application/json', ...corsHeaders }
        });
      }
    }

    // è©³ç´°æƒ…å ±è£œå®Œã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆ
    if (url.pathname === '/detail-fill') {
      try {
        console.log('ğŸ”§ Starting detail fill process...');
        
        // æ—¢å­˜ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—
        const existingDataStr = env.LIVER_DATA ? await env.LIVER_DATA.get('latest_data') : null;
        if (!existingDataStr) {
          throw new Error('No existing data found. Run /light-scrape first.');
        }
        
        const existingData = JSON.parse(existingDataStr);
        const basicOnlyLivers = existingData.data.filter(l => l.detailStatus === 'basic_only');
        
        console.log(`ğŸ“Š Found ${basicOnlyLivers.length} livers needing detail information`);
        
        if (basicOnlyLivers.length === 0) {
          return new Response(JSON.stringify({
            success: true,
            message: 'All livers already have detail information',
            totalLivers: existingData.data.length
          }), {
            headers: { 'Content-Type': 'application/json', ...corsHeaders }
          });
        }
        
        // ãƒ­ã‚°ã‚¤ãƒ³
        const loginResult = await performRobustLogin(env);
        if (!loginResult.success) {
          throw new Error(`Login failed: ${loginResult.error}`);
        }
        
        let processedCount = 0;
        let subrequestCount = 1; // ãƒ­ã‚°ã‚¤ãƒ³åˆ†
        const maxDetails = Math.min(basicOnlyLivers.length, 40); // å®‰å…¨ãªä¸Šé™
        
        for (let i = 0; i < maxDetails && subrequestCount < 45; i++) {
          const liver = basicOnlyLivers[i];
          
          console.log(`ğŸ” Filling details for: ${liver.name} (${i + 1}/${maxDetails})`);
          
          try {
            const detailInfo = await scrapeDetailPageWithAuth(liver.detailUrl, loginResult.cookies, env);
            subrequestCount++;
            
            // æ—¢å­˜ãƒ‡ãƒ¼ã‚¿ã‚’æ›´æ–°
            const liverIndex = existingData.data.findIndex(l => l.id === liver.id);
            if (liverIndex !== -1) {
              Object.assign(existingData.data[liverIndex], detailInfo);
              delete existingData.data[liverIndex].detailStatus; // ãƒãƒ¼ã‚¯ã‚’å‰Šé™¤
              processedCount++;
            }
            
            await sleep(300);
            
          } catch (error) {
            console.error(`âŒ Failed to fill details for ${liver.name}:`, error.message);
            subrequestCount++;
          }
        }
        
        // æ›´æ–°ã•ã‚ŒãŸãƒ‡ãƒ¼ã‚¿ã‚’ä¿å­˜
        existingData.lastUpdate = new Date().toISOString();
        existingData.timestamp = Date.now();
        
        if (env.LIVER_DATA) {
          await env.LIVER_DATA.put('latest_data', JSON.stringify(existingData));
        }
        
        console.log(`âœ… Detail fill completed: ${processedCount} livers updated`);
        
        return new Response(JSON.stringify({
          success: true,
          message: 'Detail fill completed',
          processedCount: processedCount,
          remainingBasicOnly: basicOnlyLivers.length - processedCount,
          subrequestsUsed: subrequestCount,
          continueWith: processedCount < basicOnlyLivers.length ? 
            `curl "${new URL(request.url).origin}/detail-fill"` : null
        }), {
          headers: { 'Content-Type': 'application/json', ...corsHeaders }
        });
        
      } catch (error) {
        console.error('âŒ Detail fill failed:', error);
        return new Response(JSON.stringify({
          success: false,
          error: error.message
        }), {
          status: 500,
          headers: { 'Content-Type': 'application/json', ...corsHeaders }
        });
      }
    }

    if (url.pathname === '/minimal-scrape') {
      try {
        const url_params = new URL(request.url);
        const maxPages = parseInt(url_params.searchParams.get('pages') || '5');
        const detailsTotal = parseInt(url_params.searchParams.get('details') || '5'); // å…¨ä½“ã§5äººã¾ã§
        
        console.log(`ğŸš€ Minimal scraping started (max pages: ${maxPages}, total details: ${detailsTotal})`);
        
        // ãƒ­ã‚°ã‚¤ãƒ³å‡¦ç†
        const loginResult = await performRobustLogin(env);
        if (!loginResult.success) {
          throw new Error(`Login failed: ${loginResult.error}`);
        }
        
        let allLivers = [];
        let currentPage = 1;
        let consecutiveEmptyPages = 0;
        let totalSubrequests = 1; // ãƒ­ã‚°ã‚¤ãƒ³ã§1å›ä½¿ç”¨æ¸ˆã¿
        let detailsProcessed = 0;
        
        // è¶…è»½é‡ç‰ˆ: æœ€å°é™ã®subrequestä½¿ç”¨
        while (currentPage <= maxPages && consecutiveEmptyPages < 2 && totalSubrequests < 20) {
          console.log(`ğŸ“„ Minimal processing page ${currentPage}... (subrequests used: ${totalSubrequests})`);
          
          const pageUrl = currentPage === 1 
            ? 'https://www.comisapolive.com/liver/list/?q=&collaboration=&achievements=&rank=&app=&follower1=&follower2=&since=&gender=&age1=&age2=&regist=&search=1'
            : `https://www.comisapolive.com/liver/list/?q=&collaboration=&achievements=&rank=&app=&follower1=&follower2=&since=&gender=&age1=&age2=&regist=&search=1&page=${currentPage}`;
          
          // ãƒšãƒ¼ã‚¸ã‚’å–å¾—
          const pageResponse = await fetch(pageUrl, {
            headers: {
              'Cookie': loginResult.cookies,
              'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36',
              'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8',
              'Accept-Language': 'ja,en-US;q=0.9,en;q=0.8',
              'Referer': currentPage === 1 ? 'https://www.comisapolive.com/' : `https://www.comisapolive.com/liver/list/?page=${currentPage-1}`
            }
          });
          
          totalSubrequests++; // ãƒšãƒ¼ã‚¸å–å¾—ã§1å›
          console.log(`ğŸ“„ Page ${currentPage} response: ${pageResponse.status} (subrequests: ${totalSubrequests})`);
          
          if (!pageResponse.ok) {
            console.log(`âš ï¸ Page ${currentPage} failed with status ${pageResponse.status}`);
            consecutiveEmptyPages++;
            currentPage++;
            continue;
          }
          
          const html = await pageResponse.text();
          
          // ãƒšãƒ¼ã‚¸ãƒ‡ãƒ¼ã‚¿ã‚’è§£æï¼ˆè©³ç´°å–å¾—ãªã—ï¼‰
          const pageData = await parseHTMLPageWithDetails(html, env, currentPage);
          
          if (pageData.length === 0) {
            console.log(`ğŸ“„ Page ${currentPage}: No data found`);
            consecutiveEmptyPages++;
            currentPage++;
            continue;
          }
          
          console.log(`ğŸ“„ Page ${currentPage}: Found ${pageData.length} livers`);
          consecutiveEmptyPages = 0;
          
          // å…¨ã¦ã®ãƒ©ã‚¤ãƒãƒ¼ã‚’åŸºæœ¬æƒ…å ±ã¨ã—ã¦è¿½åŠ 
          allLivers = allLivers.concat(pageData);
          
          currentPage++;
          await sleep(500); // çŸ­ã„ä¼‘æ†©
        }
        
        console.log(`ğŸ“Š Basic data collection completed: ${allLivers.length} livers from ${currentPage - 1} pages`);
        
        // ğŸ”§ è©³ç´°æƒ…å ±ã¯æœ€åˆã®Näººã®ã¿å–å¾—ï¼ˆå…¨ä½“åˆ¶é™ï¼‰
        for (let i = 0; i < Math.min(allLivers.length, detailsTotal) && totalSubrequests < 45; i++) {
          const liver = allLivers[i];
          
          if (liver.detailUrl) {
            console.log(`ğŸ” Getting details for: ${liver.name} (${i + 1}/${detailsTotal}) - subrequest ${totalSubrequests + 1}`);
            
            try {
              const detailInfo = await scrapeDetailPageWithAuth(liver.detailUrl, loginResult.cookies, env);
              totalSubrequests++; // è©³ç´°ãƒšãƒ¼ã‚¸å–å¾—ã§1å›
              
              Object.assign(liver, detailInfo);
              
              if (detailInfo.profileInfo && detailInfo.profileInfo.gender) {
                console.log(`ğŸ‘¤ Gender found for ${liver.name}: ${detailInfo.profileInfo.gender}`);
              }
              
              detailsProcessed++;
              await sleep(300);
              
            } catch (detailError) {
              console.error(`âŒ Failed to get details for ${liver.name}:`, detailError.message);
              totalSubrequests++; // ã‚¨ãƒ©ãƒ¼ã§ã‚‚ã‚«ã‚¦ãƒ³ãƒˆ
            }
          }
        }
        
        // è©³ç´°æœªå–å¾—ã®ãƒ©ã‚¤ãƒãƒ¼ã«ãƒãƒ¼ã‚¯
        for (let i = detailsTotal; i < allLivers.length; i++) {
          allLivers[i].detailStatus = 'pending';
        }
        
        const actualPagesProcessed = currentPage - 1;
        
        console.log(`ğŸ‰ Minimal scraping completed: ${allLivers.length} livers (${detailsProcessed} with details) from ${actualPagesProcessed} pages`);
        
        // KVã«ä¿å­˜
        const finalData = {
          timestamp: Date.now(),
          total: allLivers.length,
          data: allLivers,
          lastUpdate: new Date().toISOString(),
          pagesProcessed: actualPagesProcessed,
          subrequestsUsed: totalSubrequests,
          method: 'minimal_scraping',
          stats: {
            withDetails: detailsProcessed,
            pending: allLivers.length - detailsProcessed
          }
        };
        
        if (env.LIVER_DATA) {
          await env.LIVER_DATA.put('latest_data', JSON.stringify(finalData));
          console.log(`ğŸ’¾ Saved ${allLivers.length} livers to KV storage`);
        }
        
        return new Response(JSON.stringify({
          success: true,
          message: 'Minimal scraping completed',
          totalProcessed: allLivers.length,
          withDetails: detailsProcessed,
          pending: allLivers.length - detailsProcessed,
          pagesProcessed: actualPagesProcessed,
          subrequestsUsed: totalSubrequests,
          lastUpdate: finalData.lastUpdate,
          sampleData: allLivers.slice(0, 3),
          pageBreakdown: allLivers.reduce((acc, liver) => {
            acc[`page_${liver.page}`] = (acc[`page_${liver.page}`] || 0) + 1;
            return acc;
          }, {}),
          nextSteps: {
            getMoreDetails: allLivers.length > detailsProcessed ? 
              `curl "${new URL(request.url).origin}/detail-batch"` : null,
            checkData: `curl "${new URL(request.url).origin}/api/livers"`
          }
        }, null, 2), {
          headers: { 'Content-Type': 'application/json', ...corsHeaders }
        });
        
      } catch (error) {
        console.error('âŒ Minimal scraping failed:', error);
        return new Response(JSON.stringify({
          success: false,
          error: error.message,
          suggestion: "Try reducing pages to 1-3 or details to 1-3"
        }), {
          status: 500,
          headers: { 'Content-Type': 'application/json', ...corsHeaders }
        });
      }
    }

    // è©³ç´°æƒ…å ±ã‚’å°‘ã—ãšã¤å–å¾—ã™ã‚‹ã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆ
    if (url.pathname === '/detail-batch') {
      try {
        const batchSize = parseInt(new URL(request.url).searchParams.get('batch') || '5');
        
        console.log(`ğŸ”§ Starting detail batch process (batch size: ${batchSize})...`);
        
        // æ—¢å­˜ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—
        const existingDataStr = env.LIVER_DATA ? await env.LIVER_DATA.get('latest_data') : null;
        if (!existingDataStr) {
          throw new Error('No existing data found. Run /minimal-scrape first.');
        }
        
        const existingData = JSON.parse(existingDataStr);
        const pendingLivers = existingData.data.filter(l => l.detailStatus === 'pending');
        
        console.log(`ğŸ“Š Found ${pendingLivers.length} livers needing detail information`);
        
        if (pendingLivers.length === 0) {
          return new Response(JSON.stringify({
            success: true,
            message: 'All livers already processed',
            totalLivers: existingData.data.length,
            allComplete: true
          }), {
            headers: { 'Content-Type': 'application/json', ...corsHeaders }
          });
        }
        
        // ãƒ­ã‚°ã‚¤ãƒ³
        const loginResult = await performRobustLogin(env);
        if (!loginResult.success) {
          throw new Error(`Login failed: ${loginResult.error}`);
        }
        
        let processedCount = 0;
        let subrequestCount = 1; // ãƒ­ã‚°ã‚¤ãƒ³åˆ†
        const processBatch = Math.min(pendingLivers.length, batchSize, 40); // å®‰å…¨ãªä¸Šé™
        
        for (let i = 0; i < processBatch && subrequestCount < 45; i++) {
          const liver = pendingLivers[i];
          
          console.log(`ğŸ” Processing details for: ${liver.name} (${i + 1}/${processBatch})`);
          
          try {
            const detailInfo = await scrapeDetailPageWithAuth(liver.detailUrl, loginResult.cookies, env);
            subrequestCount++;
            
            // æ—¢å­˜ãƒ‡ãƒ¼ã‚¿ã‚’æ›´æ–°
            const liverIndex = existingData.data.findIndex(l => l.id === liver.id);
            if (liverIndex !== -1) {
              Object.assign(existingData.data[liverIndex], detailInfo);
              delete existingData.data[liverIndex].detailStatus; // pendingãƒãƒ¼ã‚¯ã‚’å‰Šé™¤
              processedCount++;
            }
            
            if (detailInfo.profileInfo && detailInfo.profileInfo.gender) {
              console.log(`ğŸ‘¤ Gender found for ${liver.name}: ${detailInfo.profileInfo.gender}`);
            }
            
            await sleep(500);
            
          } catch (error) {
            console.error(`âŒ Failed to process details for ${liver.name}:`, error.message);
            subrequestCount++;
          }
        }
        
        // çµ±è¨ˆã‚’æ›´æ–°
        const remainingPending = existingData.data.filter(l => l.detailStatus === 'pending').length;
        existingData.stats = {
          withDetails: existingData.data.filter(l => !l.detailStatus).length,
          pending: remainingPending
        };
        
        // æ›´æ–°ã•ã‚ŒãŸãƒ‡ãƒ¼ã‚¿ã‚’ä¿å­˜
        existingData.lastUpdate = new Date().toISOString();
        existingData.timestamp = Date.now();
        
        if (env.LIVER_DATA) {
          await env.LIVER_DATA.put('latest_data', JSON.stringify(existingData));
        }
        
        console.log(`âœ… Detail batch completed: ${processedCount} livers updated`);
        
        return new Response(JSON.stringify({
          success: true,
          message: 'Detail batch completed',
          processedThisBatch: processedCount,
          remainingPending: remainingPending,
          subrequestsUsed: subrequestCount,
          allComplete: remainingPending === 0,
          continueWith: remainingPending > 0 ? 
            `curl "${new URL(request.url).origin}/detail-batch?batch=${batchSize}"` : null,
          checkProgress: `curl "${new URL(request.url).origin}/api/livers" | jq '{total: .total, withDetails: .stats.withDetails, pending: .stats.pending}'`
        }), {
          headers: { 'Content-Type': 'application/json', ...corsHeaders }
        });
        
      } catch (error) {
        console.error('âŒ Detail batch failed:', error);
        return new Response(JSON.stringify({
          success: false,
          error: error.message
        }), {
          status: 500,
          headers: { 'Content-Type': 'application/json', ...corsHeaders }
        });
      }
    }

    if (url.pathname === '/kv-test') {
      try {
        console.log('ğŸ”§ KV Test - Environment check:');
        console.log('- env type:', typeof env);
        console.log('- env keys:', Object.keys(env));
        console.log('- LIVER_DATA exists:', !!env.LIVER_DATA);
        console.log('- LIVER_DATA type:', typeof env.LIVER_DATA);

        // ãƒ†ã‚¹ãƒˆãƒ‡ãƒ¼ã‚¿ã‚’æ›¸ãè¾¼ã¿
        const testData = {
          timestamp: Date.now(),
          test: 'KV storage test',
          message: 'This is a test write',
          randomValue: Math.random()
        };

        if (env.LIVER_DATA) {
          console.log('ğŸ“ Attempting to write test data...');
          await env.LIVER_DATA.put('test_key', JSON.stringify(testData));
          console.log('âœ… Test data written successfully');

          // ã™ãã«èª­ã¿å–ã‚Šãƒ†ã‚¹ãƒˆ
          console.log('ğŸ“– Attempting to read test data...');
          const readResult = await env.LIVER_DATA.get('test_key');
          console.log('ğŸ“– Read result:', readResult ? 'SUCCESS' : 'FAILED');

          if (readResult) {
            const parsedResult = JSON.parse(readResult);
            console.log('ğŸ“– Parsed result:', parsedResult);
          }

          // latest_dataã‚­ãƒ¼ã‚‚ç¢ºèª
          console.log('ğŸ” Checking latest_data key...');
          const latestDataResult = await env.LIVER_DATA.get('latest_data');
          console.log('ğŸ” latest_data exists:', !!latestDataResult);
          if (latestDataResult) {
            const parsedLatest = JSON.parse(latestDataResult);
            console.log('ğŸ” latest_data summary:', {
              total: parsedLatest.total,
              timestamp: parsedLatest.timestamp,
              lastUpdate: parsedLatest.lastUpdate
            });
          }

          return new Response(JSON.stringify({
            success: true,
            kvExists: !!env.LIVER_DATA,
            writeTest: 'success',
            readTest: readResult ? 'success' : 'failed',
            testData: readResult ? JSON.parse(readResult) : null,
            latestDataExists: !!latestDataResult,
            latestDataSummary: latestDataResult ? {
              total: JSON.parse(latestDataResult).total,
              lastUpdate: JSON.parse(latestDataResult).lastUpdate
            } : null,
            envInfo: {
              keys: Object.keys(env),
              liverDataType: typeof env.LIVER_DATA
            }
          }, null, 2), {
            headers: { 'Content-Type': 'application/json', ...corsHeaders }
          });
        } else {
          console.log('âŒ LIVER_DATA is not available');
          return new Response(JSON.stringify({
            success: false,
            error: 'LIVER_DATA KV namespace not found',
            envKeys: Object.keys(env),
            suggestion: 'Check wrangler.toml KV namespace configuration'
          }, null, 2), {
            headers: { 'Content-Type': 'application/json', ...corsHeaders }
          });
        }

      } catch (error) {
        console.error('KV Test error:', error);
        return new Response(JSON.stringify({
          success: false,
          error: error.message,
          stack: error.stack
        }, null, 2), {
          status: 500,
          headers: { 'Content-Type': 'application/json', ...corsHeaders }
        });
      }
    }

    if (url.pathname === '/fix-images') {
      try {
        const batchSize = parseInt(new URL(request.url).searchParams.get('batch') || '3');
        
        console.log(`ğŸ–¼ï¸ Starting image fix process (batch size: ${batchSize})...`);
        
        // æ—¢å­˜ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—
        const existingDataStr = env.LIVER_DATA ? await env.LIVER_DATA.get('latest_data') : null;
        if (!existingDataStr) {
          throw new Error('No existing data found.');
        }
        
        const existingData = JSON.parse(existingDataStr);
        let subrequestCount = 0;
        let imagesProcessed = 0;
        
        // æœ€åˆã®Näººã®ç”»åƒã®ã¿å‡¦ç†
        for (let i = 0; i < Math.min(existingData.data.length, batchSize) && subrequestCount < 45; i++) {
          const liver = existingData.data[i];
          
          console.log(`ğŸ–¼ï¸ Processing image for: ${liver.name} (${i + 1}/${batchSize})`);
          
          try {
            // å…ƒç”»åƒURLã‚’æ§‹ç¯‰
            const originalImageUrl = `https://www.comisapolive.com/user_files_thumbnail/${liver.originalId}/`;
            
            // ç”»åƒã‚’å–å¾—ï¼ˆHEADãƒªã‚¯ã‚¨ã‚¹ãƒˆã§å­˜åœ¨ç¢ºèªï¼‰
            const headResponse = await fetch(originalImageUrl, { method: 'HEAD' });
            subrequestCount++;
            
            if (headResponse.ok) {
              // å®Ÿéš›ã®ç”»åƒã‚’å–å¾—
              const imageResponse = await fetch(originalImageUrl);
              subrequestCount++;
              
              if (imageResponse.ok) {
                const imageBuffer = await imageResponse.arrayBuffer();
                const imageId = `${liver.id}.jpg`;
                
                // R2ã«ä¿å­˜
                if (env.IMAGES) {
                  await env.IMAGES.put(imageId, imageBuffer, {
                    httpMetadata: { contentType: 'image/jpeg' }
                  });
                  
                  console.log(`âœ… Saved image for ${liver.name}: ${imageId}`);
                  imagesProcessed++;
                }
              }
            }
            
            await sleep(200); // çŸ­ã„ä¼‘æ†©
            
          } catch (imageError) {
            console.error(`âŒ Failed to process image for ${liver.name}:`, imageError.message);
            subrequestCount++;
          }
        }
        
        return new Response(JSON.stringify({
          success: true,
          message: 'Image fix completed',
          imagesProcessed: imagesProcessed,
          subrequestsUsed: subrequestCount,
          batchSize: batchSize,
          nextBatch: imagesProcessed < existingData.data.length ? 
            `curl "${new URL(request.url).origin}/fix-images?batch=${batchSize}"` : null
        }, null, 2), {
          headers: { 'Content-Type': 'application/json', ...corsHeaders }
        });
        
      } catch (error) {
        console.error('âŒ Image fix failed:', error);
        return new Response(JSON.stringify({
          success: false,
          error: error.message
        }), {
          status: 500,
          headers: { 'Content-Type': 'application/json', ...corsHeaders }
        });
      }
    }

    // ç”»åƒç„¡åŠ¹åŒ–å‡¦ç†ï¼šç”»åƒãªã—ã§APIã‚’ä½¿ã„ã‚„ã™ãã™ã‚‹
    if (url.pathname === '/api/livers-no-images') {
      try {
        const data = env.LIVER_DATA ? await env.LIVER_DATA.get('latest_data') : null;
        
        if (!data) {
          return new Response(JSON.stringify({
            data: [], 
            total: 0, 
            error: "No data found in storage"
          }), {
            headers: { 'Content-Type': 'application/json', ...corsHeaders }
          });
        }
        
        const parsedData = JSON.parse(data);
        
        // ç”»åƒURLã‚’ç„¡åŠ¹åŒ–ã¾ãŸã¯ãƒ—ãƒ¬ãƒ¼ã‚¹ãƒ›ãƒ«ãƒ€ãƒ¼ã«ç½®æ›
        const cleanedData = {
          ...parsedData,
          data: parsedData.data.map(liver => ({
            ...liver,
            imageUrl: null, // ç”»åƒURLã‚’ç„¡åŠ¹åŒ–
            hasImageData: false,
            profileImages: liver.profileImages ? liver.profileImages.map(img => ({
              ...img,
              url: null, // ãƒ—ãƒ­ãƒ•ã‚£ãƒ¼ãƒ«ç”»åƒã‚‚ç„¡åŠ¹åŒ–
              originalUrl: img.originalUrl // å…ƒURLã¯ä¿æŒ
            })) : []
          }))
        };
        
        return new Response(JSON.stringify(cleanedData), {
          headers: { 
            'Content-Type': 'application/json',
            'Cache-Control': 'max-age=3600',
            ...corsHeaders
          }
        });
        
      } catch (error) {
        return new Response(JSON.stringify({
          data: [], 
          total: 0, 
          error: error.message
        }), {
          status: 500,
          headers: { 'Content-Type': 'application/json', ...corsHeaders }
        });
      }
    }

    if (url.pathname === '/fix-images-v2') {
      try {
        const batchSize = parseInt(new URL(request.url).searchParams.get('batch') || '2');
        
        console.log(`ğŸ–¼ï¸ Starting improved image fix process (batch size: ${batchSize})...`);
        
        // æ—¢å­˜ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—
        const existingDataStr = env.LIVER_DATA ? await env.LIVER_DATA.get('latest_data') : null;
        if (!existingDataStr) {
          throw new Error('No existing data found.');
        }
        
        const existingData = JSON.parse(existingDataStr);
        let subrequestCount = 0;
        let imagesProcessed = 0;
        const results = [];
        
        // æœ€åˆã®Näººã®ç”»åƒã®ã¿å‡¦ç†
        for (let i = 0; i < Math.min(existingData.data.length, batchSize) && subrequestCount < 40; i++) {
          const liver = existingData.data[i];
          
          console.log(`ğŸ–¼ï¸ Processing image for: ${liver.name} (ID: ${liver.originalId})`);
          
          const result = {
            liverName: liver.name,
            originalId: liver.originalId,
            success: false,
            error: null,
            imageUrl: null
          };
          
          try {
            // profileImages ã‹ã‚‰å…ƒã®URLã‚’å–å¾—
            let originalImageUrl = null;
            
            if (liver.profileImages && liver.profileImages.length > 0) {
              originalImageUrl = liver.profileImages[0].originalUrl;
              console.log(`ğŸ“¸ Using profileImage URL: ${originalImageUrl}`);
            } else {
              // ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯: æ¨æ¸¬URLã‚’æ§‹ç¯‰
              originalImageUrl = `https://www.comisapolive.com/user_files_thumbnail/${liver.originalId}/`;
              console.log(`ğŸ“¸ Using fallback URL: ${originalImageUrl}`);
            }
            
            if (!originalImageUrl) {
              throw new Error('No image URL available');
            }
            
            // ç”»åƒã‚’å–å¾—
            console.log(`ğŸ“¥ Fetching image from: ${originalImageUrl}`);
            const imageResponse = await fetch(originalImageUrl);
            subrequestCount++;
            
            console.log(`ğŸ“¥ Image response status: ${imageResponse.status}`);
            
            if (imageResponse.ok) {
              const imageBuffer = await imageResponse.arrayBuffer();
              const imageSize = imageBuffer.byteLength;
              
              console.log(`ğŸ“ Image size: ${imageSize} bytes`);
              
              if (imageSize > 0) {
                const imageId = `${liver.id}.jpg`;
                
                // R2ã«ä¿å­˜
                if (env.IMAGES) {
                  await env.IMAGES.put(imageId, imageBuffer, {
                    httpMetadata: { contentType: 'image/jpeg' }
                  });
                  
                  console.log(`âœ… Saved image for ${liver.name}: ${imageId}`);
                  result.success = true;
                  result.imageUrl = `/api/images/${imageId}`;
                  imagesProcessed++;
                } else {
                  throw new Error('IMAGES binding not available');
                }
              } else {
                throw new Error('Empty image data');
              }
            } else {
              throw new Error(`HTTP ${imageResponse.status}: ${imageResponse.statusText}`);
            }
            
            await sleep(500); // é•·ã‚ã®ä¼‘æ†©
            
          } catch (imageError) {
            console.error(`âŒ Failed to process image for ${liver.name}:`, imageError);
            result.error = imageError.message;
            subrequestCount++;
          }
          
          results.push(result);
        }
        
        return new Response(JSON.stringify({
          success: true,
          message: 'Improved image fix completed',
          imagesProcessed: imagesProcessed,
          subrequestsUsed: subrequestCount,
          batchSize: batchSize,
          results: results,
          nextBatch: imagesProcessed < existingData.data.length ? 
            `curl "${new URL(request.url).origin}/fix-images-v2?batch=${batchSize}"` : null
        }, null, 2), {
          headers: { 'Content-Type': 'application/json', ...corsHeaders }
        });
        
      } catch (error) {
        console.error('âŒ Improved image fix failed:', error);
        return new Response(JSON.stringify({
          success: false,
          error: error.message,
          stack: error.stack
        }), {
          status: 500,
          headers: { 'Content-Type': 'application/json', ...corsHeaders }
        });
      }
    }

    // ç”»åƒURLãƒ†ã‚¹ãƒˆç”¨ã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆ
    if (url.pathname === '/test-image-urls') {
      try {
        const existingDataStr = env.LIVER_DATA ? await env.LIVER_DATA.get('latest_data') : null;
        if (!existingDataStr) {
          throw new Error('No existing data found.');
        }
        
        const existingData = JSON.parse(existingDataStr);
        const testResults = [];
        
        // æœ€åˆã®3äººã®URLã‚’ãƒ†ã‚¹ãƒˆ
        for (let i = 0; i < Math.min(3, existingData.data.length); i++) {
          const liver = existingData.data[i];
          
          const urlTests = [];
          
          // profileImages ã®URL
          if (liver.profileImages && liver.profileImages.length > 0) {
            urlTests.push({
              type: 'profileImage',
              url: liver.profileImages[0].originalUrl
            });
          }
          
          // æ¨æ¸¬URL
          urlTests.push({
            type: 'fallback',
            url: `https://www.comisapolive.com/user_files_thumbnail/${liver.originalId}/`
          });
          
          testResults.push({
            liverName: liver.name,
            originalId: liver.originalId,
            availableUrls: urlTests
          });
        }
        
        return new Response(JSON.stringify({
          success: true,
          message: 'Image URL test results',
          testResults: testResults
        }, null, 2), {
          headers: { 'Content-Type': 'application/json', ...corsHeaders }
        });
        
      } catch (error) {
        return new Response(JSON.stringify({
          success: false,
          error: error.message
        }), {
          status: 500,
          headers: { 'Content-Type': 'application/json', ...corsHeaders }
        });
      }
    }

    if (url.pathname === '/fix-images-browser') {
      try {
        const batchSize = parseInt(new URL(request.url).searchParams.get('batch') || '2');
        
        console.log(`ğŸ–¼ï¸ Starting browser-like image fix process (batch size: ${batchSize})...`);
        
        // æ—¢å­˜ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—
        const existingDataStr = env.LIVER_DATA ? await env.LIVER_DATA.get('latest_data') : null;
        if (!existingDataStr) {
          throw new Error('No existing data found.');
        }
        
        const existingData = JSON.parse(existingDataStr);
        let subrequestCount = 0;
        let imagesProcessed = 0;
        const results = [];
        
        // æœ€åˆã®Näººã®ç”»åƒã®ã¿å‡¦ç†
        for (let i = 0; i < Math.min(existingData.data.length, batchSize) && subrequestCount < 40; i++) {
          const liver = existingData.data[i];
          
          console.log(`ğŸ–¼ï¸ Processing browser-like image for: ${liver.name} (ID: ${liver.originalId})`);
          
          const result = {
            liverName: liver.name,
            originalId: liver.originalId,
            success: false,
            error: null,
            imageUrl: null,
            statusCode: null
          };
          
          try {
            // profileImages ã‹ã‚‰å…ƒã®URLã‚’å–å¾—
            let originalImageUrl = null;
            
            if (liver.profileImages && liver.profileImages.length > 0) {
              originalImageUrl = liver.profileImages[0].originalUrl;
              console.log(`ğŸ“¸ Using profileImage URL: ${originalImageUrl}`);
            }
            
            if (!originalImageUrl) {
              throw new Error('No image URL available');
            }
            
            // ã‚ˆã‚Šå®Œå…¨ãªãƒ–ãƒ©ã‚¦ã‚¶ãƒ˜ãƒƒãƒ€ãƒ¼ã§ç”»åƒã‚’å–å¾—
            console.log(`ğŸ“¥ Fetching browser-like image from: ${originalImageUrl}`);
            const imageResponse = await fetch(originalImageUrl, {
              headers: {
                'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
                'Accept': 'image/avif,image/webp,image/apng,image/svg+xml,image/*,*/*;q=0.8',
                'Accept-Encoding': 'gzip, deflate, br',
                'Accept-Language': 'ja,en-US;q=0.9,en;q=0.8',
                'Cache-Control': 'no-cache',
                'Pragma': 'no-cache',
                'Sec-Fetch-Dest': 'image',
                'Sec-Fetch-Mode': 'no-cors',
                'Sec-Fetch-Site': 'same-origin',
                'sec-ch-ua': '"Not_A Brand";v="8", "Chromium";v="120", "Google Chrome";v="120"',
                'sec-ch-ua-mobile': '?0',
                'sec-ch-ua-platform': '"macOS"'
              }
            });
            subrequestCount++;
            
            result.statusCode = imageResponse.status;
            console.log(`ğŸ“¥ Browser-like image response status: ${imageResponse.status}`);
            console.log(`ğŸ“¥ Response headers:`, Object.fromEntries(imageResponse.headers.entries()));
            
            if (imageResponse.ok) {
              const imageBuffer = await imageResponse.arrayBuffer();
              const imageSize = imageBuffer.byteLength;
              
              console.log(`ğŸ“ Image size: ${imageSize} bytes`);
              
              if (imageSize > 0) {
                const imageId = `${liver.id}.jpg`;
                
                // R2ã«ä¿å­˜
                if (env.IMAGES) {
                  await env.IMAGES.put(imageId, imageBuffer, {
                    httpMetadata: { 
                      contentType: imageResponse.headers.get('content-type') || 'image/jpeg'
                    }
                  });
                  
                  console.log(`âœ… Saved browser-like image for ${liver.name}: ${imageId}`);
                  result.success = true;
                  result.imageUrl = `/api/images/${imageId}`;
                  imagesProcessed++;
                } else {
                  throw new Error('IMAGES binding not available');
                }
              } else {
                throw new Error('Empty image data');
              }
            } else {
              // ãƒ¬ã‚¹ãƒãƒ³ã‚¹ãƒœãƒ‡ã‚£ã‚‚ç¢ºèª
              const errorText = await imageResponse.text();
              console.log(`âŒ Error response body:`, errorText.substring(0, 200));
              throw new Error(`HTTP ${imageResponse.status}: ${imageResponse.statusText}`);
            }
            
            await sleep(2000); // é•·ã‚ã®ä¼‘æ†©ã§ã‚µãƒ¼ãƒãƒ¼è² è·ã‚’è»½æ¸›
            
          } catch (imageError) {
            console.error(`âŒ Failed to process browser-like image for ${liver.name}:`, imageError);
            result.error = imageError.message;
            subrequestCount++;
          }
          
          results.push(result);
        }
        
        return new Response(JSON.stringify({
          success: true,
          message: 'Browser-like image fix completed',
          imagesProcessed: imagesProcessed,
          subrequestsUsed: subrequestCount,
          batchSize: batchSize,
          results: results,
          nextBatch: imagesProcessed > 0 && imagesProcessed < existingData.data.length ? 
            `curl "${new URL(request.url).origin}/fix-images-browser?batch=${batchSize}"` : null
        }, null, 2), {
          headers: { 'Content-Type': 'application/json', ...corsHeaders }
        });
        
      } catch (error) {
        console.error('âŒ Browser-like image fix failed:', error);
        return new Response(JSON.stringify({
          success: false,
          error: error.message,
          stack: error.stack
        }), {
          status: 500,
          headers: { 'Content-Type': 'application/json', ...corsHeaders }
        });
      }
    }

    if (url.pathname === '/fix-images-progressive') {
      try {
        const batchSize = parseInt(new URL(request.url).searchParams.get('batch') || '2');
        const skipProcessed = new URL(request.url).searchParams.get('skip') !== 'false';
        
        console.log(`ğŸ–¼ï¸ Starting progressive image fix process (batch size: ${batchSize}, skip processed: ${skipProcessed})...`);
        
        // æ—¢å­˜ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—
        const existingDataStr = env.LIVER_DATA ? await env.LIVER_DATA.get('latest_data') : null;
        if (!existingDataStr) {
          throw new Error('No existing data found.');
        }
        
        const existingData = JSON.parse(existingDataStr);
        let subrequestCount = 0;
        let imagesProcessed = 0;
        const results = [];
        let processedCount = 0;
        let skippedCount = 0;
        
        // R2ã§æ—¢å­˜ç”»åƒã‚’ãƒã‚§ãƒƒã‚¯ã—ã¦å‡¦ç†æ¸ˆã¿ã‚’ç‰¹å®š
        const processedImages = new Set();
        if (skipProcessed) {
          console.log('ğŸ” Checking for existing images in R2...');
          // ç°¡æ˜“çš„ã«æœ€åˆã®æ•°äººã‚’ãƒã‚§ãƒƒã‚¯
          for (let i = 0; i < Math.min(10, existingData.data.length); i++) {
            const liver = existingData.data[i];
            const imageId = `${liver.id}.jpg`;
            try {
              const existingImage = await env.IMAGES.get(imageId);
              if (existingImage) {
                processedImages.add(liver.id);
                console.log(`âœ“ Already processed: ${liver.name}`);
              }
            } catch (e) {
              // ç”»åƒãŒå­˜åœ¨ã—ãªã„ï¼ˆæ­£å¸¸ï¼‰
            }
          }
          console.log(`ğŸ“Š Found ${processedImages.size} already processed images`);
        }
        
        // æœªå‡¦ç†ã®ãƒ©ã‚¤ãƒãƒ¼ã®ã¿ã‚’å¯¾è±¡ã«å‡¦ç†
        let processedInBatch = 0;
        for (let i = 0; i < existingData.data.length && processedInBatch < batchSize && subrequestCount < 40; i++) {
          const liver = existingData.data[i];
          
          // æ—¢ã«å‡¦ç†æ¸ˆã¿ã®å ´åˆã¯ã‚¹ã‚­ãƒƒãƒ—
          if (skipProcessed && processedImages.has(liver.id)) {
            skippedCount++;
            continue;
          }
          
          console.log(`ğŸ–¼ï¸ Processing progressive image for: ${liver.name} (ID: ${liver.originalId})`);
          
          const result = {
            liverName: liver.name,
            originalId: liver.originalId,
            liverId: liver.id,
            success: false,
            error: null,
            imageUrl: null,
            statusCode: null,
            skipped: false
          };
          
          try {
            // profileImages ã‹ã‚‰å…ƒã®URLã‚’å–å¾—
            let originalImageUrl = null;
            
            if (liver.profileImages && liver.profileImages.length > 0) {
              originalImageUrl = liver.profileImages[0].originalUrl;
              console.log(`ğŸ“¸ Using profileImage URL: ${originalImageUrl}`);
            }
            
            if (!originalImageUrl) {
              throw new Error('No image URL available');
            }
            
            // ãƒ–ãƒ©ã‚¦ã‚¶ãƒ©ã‚¤ã‚¯ãªãƒ˜ãƒƒãƒ€ãƒ¼ã§ç”»åƒã‚’å–å¾—
            console.log(`ğŸ“¥ Fetching progressive image from: ${originalImageUrl}`);
            const imageResponse = await fetch(originalImageUrl, {
              headers: {
                'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
                'Accept': 'image/avif,image/webp,image/apng,image/svg+xml,image/*,*/*;q=0.8',
                'Accept-Encoding': 'gzip, deflate, br',
                'Accept-Language': 'ja,en-US;q=0.9,en;q=0.8',
                'Cache-Control': 'no-cache',
                'Pragma': 'no-cache',
                'Sec-Fetch-Dest': 'image',
                'Sec-Fetch-Mode': 'no-cors',
                'Sec-Fetch-Site': 'same-origin',
                'sec-ch-ua': '"Not_A Brand";v="8", "Chromium";v="120", "Google Chrome";v="120"',
                'sec-ch-ua-mobile': '?0',
                'sec-ch-ua-platform': '"macOS"'
              }
            });
            subrequestCount++;
            
            result.statusCode = imageResponse.status;
            console.log(`ğŸ“¥ Progressive image response status: ${imageResponse.status}`);
            
            if (imageResponse.ok) {
              const imageBuffer = await imageResponse.arrayBuffer();
              const imageSize = imageBuffer.byteLength;
              
              console.log(`ğŸ“ Image size: ${imageSize} bytes`);
              
              if (imageSize > 0) {
                const imageId = `${liver.id}.jpg`;
                
                // R2ã«ä¿å­˜
                if (env.IMAGES) {
                  await env.IMAGES.put(imageId, imageBuffer, {
                    httpMetadata: { 
                      contentType: imageResponse.headers.get('content-type') || 'image/jpeg'
                    }
                  });
                  
                  console.log(`âœ… Saved progressive image for ${liver.name}: ${imageId}`);
                  result.success = true;
                  result.imageUrl = `/api/images/${imageId}`;
                  imagesProcessed++;
                  processedInBatch++;
                } else {
                  throw new Error('IMAGES binding not available');
                }
              } else {
                throw new Error('Empty image data');
              }
            } else {
              throw new Error(`HTTP ${imageResponse.status}: ${imageResponse.statusText}`);
            }
            
            await sleep(1500); // é©åº¦ãªä¼‘æ†©
            
          } catch (imageError) {
            console.error(`âŒ Failed to process progressive image for ${liver.name}:`, imageError);
            result.error = imageError.message;
            subrequestCount++;
            processedInBatch++; // ã‚¨ãƒ©ãƒ¼ã§ã‚‚ã‚«ã‚¦ãƒ³ãƒˆ
          }
          
          results.push(result);
          processedCount++;
        }
        
        return new Response(JSON.stringify({
          success: true,
          message: 'Progressive image fix completed',
          imagesProcessed: imagesProcessed,
          subrequestsUsed: subrequestCount,
          batchSize: batchSize,
          skippedCount: skippedCount,
          processedCount: processedCount,
          results: results,
          totalLivers: existingData.data.length,
          nextBatch: (processedCount + skippedCount) < existingData.data.length ? 
            `curl "${new URL(request.url).origin}/fix-images-progressive?batch=${batchSize}"` : null,
          allComplete: (processedCount + skippedCount) >= existingData.data.length
        }, null, 2), {
          headers: { 'Content-Type': 'application/json', ...corsHeaders }
        });
        
      } catch (error) {
        console.error('âŒ Progressive image fix failed:', error);
        return new Response(JSON.stringify({
          success: false,
          error: error.message,
          stack: error.stack
        }), {
          status: 500,
          headers: { 'Content-Type': 'application/json', ...corsHeaders }
        });
      }
    }

    if (url.pathname === '/fix-all-images') {
      try {
        console.log(`ğŸ–¼ï¸ Starting complete image fix process...`);
        
        // æ—¢å­˜ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—
        const existingDataStr = env.LIVER_DATA ? await env.LIVER_DATA.get('latest_data') : null;
        if (!existingDataStr) {
          throw new Error('No existing data found.');
        }
        
        const existingData = JSON.parse(existingDataStr);
        let subrequestCount = 0;
        let imagesProcessed = 0;
        const results = [];
        let skippedCount = 0;
        
        // R2ã§æ—¢å­˜ç”»åƒã‚’ãƒã‚§ãƒƒã‚¯
        const processedImages = new Set();
        console.log('ğŸ” Checking for existing images in R2...');
        
        for (const liver of existingData.data) {
          const imageId = `${liver.id}.jpg`;
          try {
            const existingImage = await env.IMAGES.get(imageId);
            if (existingImage) {
              processedImages.add(liver.id);
              console.log(`âœ“ Already processed: ${liver.name}`);
            }
          } catch (e) {
            // ç”»åƒãŒå­˜åœ¨ã—ãªã„ï¼ˆæœªå‡¦ç†ï¼‰
          }
        }
        
        console.log(`ğŸ“Š Found ${processedImages.size} already processed images`);
        console.log(`ğŸ“Š Need to process ${existingData.data.length - processedImages.size} images`);
        
        // å…¨ãƒ©ã‚¤ãƒãƒ¼ã‚’å‡¦ç†ï¼ˆsubrequeståˆ¶é™ã¾ã§ï¼‰
        for (const liver of existingData.data) {
          if (subrequestCount >= 45) { // å®‰å…¨ãƒãƒ¼ã‚¸ãƒ³
            console.log(`âš ï¸ Approaching subrequest limit, stopping at ${subrequestCount}`);
            break;
          }
          
          // æ—¢ã«å‡¦ç†æ¸ˆã¿ã®å ´åˆã¯ã‚¹ã‚­ãƒƒãƒ—
          if (processedImages.has(liver.id)) {
            skippedCount++;
            results.push({
              liverName: liver.name,
              originalId: liver.originalId,
              liverId: liver.id,
              success: true,
              skipped: true,
              imageUrl: `/api/images/${liver.id}.jpg`
            });
            continue;
          }
          
          console.log(`ğŸ–¼ï¸ Processing image for: ${liver.name} (${imagesProcessed + 1}/${existingData.data.length - processedImages.size})`);
          
          const result = {
            liverName: liver.name,
            originalId: liver.originalId,
            liverId: liver.id,
            success: false,
            error: null,
            imageUrl: null,
            statusCode: null,
            skipped: false
          };
          
          try {
            // profileImages ã‹ã‚‰å…ƒã®URLã‚’å–å¾—
            let originalImageUrl = null;
            
            if (liver.profileImages && liver.profileImages.length > 0) {
              originalImageUrl = liver.profileImages[0].originalUrl;
            }
            
            if (!originalImageUrl) {
              throw new Error('No image URL available');
            }
            
            // ãƒ–ãƒ©ã‚¦ã‚¶ãƒ©ã‚¤ã‚¯ãªãƒ˜ãƒƒãƒ€ãƒ¼ã§ç”»åƒã‚’å–å¾—
            const imageResponse = await fetch(originalImageUrl, {
              headers: {
                'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
                'Accept': 'image/avif,image/webp,image/apng,image/svg+xml,image/*,*/*;q=0.8',
                'Accept-Encoding': 'gzip, deflate, br',
                'Accept-Language': 'ja,en-US;q=0.9,en;q=0.8',
                'Cache-Control': 'no-cache',
                'Pragma': 'no-cache',
                'Sec-Fetch-Dest': 'image',
                'Sec-Fetch-Mode': 'no-cors',
                'Sec-Fetch-Site': 'same-origin'
              }
            });
            subrequestCount++;
            
            result.statusCode = imageResponse.status;
            
            if (imageResponse.ok) {
              const imageBuffer = await imageResponse.arrayBuffer();
              const imageSize = imageBuffer.byteLength;
              
              if (imageSize > 0) {
                const imageId = `${liver.id}.jpg`;
                
                // R2ã«ä¿å­˜
                if (env.IMAGES) {
                  await env.IMAGES.put(imageId, imageBuffer, {
                    httpMetadata: { 
                      contentType: imageResponse.headers.get('content-type') || 'image/jpeg'
                    }
                  });
                  
                  console.log(`âœ… Saved image for ${liver.name}: ${imageId} (${imagesProcessed + 1})`);
                  result.success = true;
                  result.imageUrl = `/api/images/${imageId}`;
                  imagesProcessed++;
                } else {
                  throw new Error('IMAGES binding not available');
                }
              } else {
                throw new Error('Empty image data');
              }
            } else {
              throw new Error(`HTTP ${imageResponse.status}: ${imageResponse.statusText}`);
            }
            
            // çŸ­ã„ä¼‘æ†©ï¼ˆåŠ¹ç‡åŒ–ã®ãŸã‚çŸ­ç¸®ï¼‰
            await sleep(800);
            
          } catch (imageError) {
            console.error(`âŒ Failed to process image for ${liver.name}:`, imageError);
            result.error = imageError.message;
            subrequestCount++;
          }
          
          results.push(result);
        }
        
        const totalProcessed = processedImages.size + imagesProcessed;
        const allComplete = totalProcessed >= existingData.data.length;
        
        return new Response(JSON.stringify({
          success: true,
          message: 'Complete image fix finished',
          newImagesProcessed: imagesProcessed,
          alreadyProcessed: processedImages.size,
          totalProcessed: totalProcessed,
          totalLivers: existingData.data.length,
          subrequestsUsed: subrequestCount,
          allComplete: allComplete,
          results: results.filter(r => !r.skipped), // ã‚¹ã‚­ãƒƒãƒ—åˆ†ã¯é™¤å¤–ã—ã¦è¡¨ç¤º
          summary: {
            success: results.filter(r => r.success).length,
            failed: results.filter(r => !r.success && !r.skipped).length,
            skipped: results.filter(r => r.skipped).length
          },
          continueWith: !allComplete ? 
            `curl "${new URL(request.url).origin}/fix-all-images"` : null
        }, null, 2), {
          headers: { 'Content-Type': 'application/json', ...corsHeaders }
        });
        
      } catch (error) {
        console.error('âŒ Complete image fix failed:', error);
        return new Response(JSON.stringify({
          success: false,
          error: error.message
        }), {
          status: 500,
          headers: { 'Content-Type': 'application/json', ...corsHeaders }
        });
      }
    }
    
    if (url.pathname === '/fix-images-inline') {
      try {
        console.log(`ğŸ–¼ï¸ Starting inline image fix process...`);
        
        const existingDataStr = env.LIVER_DATA ? await env.LIVER_DATA.get('latest_data') : null;
        if (!existingDataStr) {
          throw new Error('No existing data found.');
        }
        
        const existingData = JSON.parse(existingDataStr);
        let subrequestCount = 0;
        let imagesProcessed = 0;
        let permanentlySaved = 0;
        const results = [];
        
        // å…¨ãƒ©ã‚¤ãƒãƒ¼ã®ç”»åƒã‚’å‡¦ç†
        for (const liver of existingData.data) {
          if (subrequestCount >= 45) {
            console.log(`âš ï¸ Subrequest limit reached`);
            break;
          }
          
          console.log(`ğŸ” Processing image for: ${liver.name}`);
          
          // ç”»åƒå­˜åœ¨ç¢ºèªï¼ˆã‚¤ãƒ³ãƒ©ã‚¤ãƒ³ï¼‰
          const imageId = `${liver.id}.jpg`;
          let imageExists = false;
          
          try {
            const r2Object = await env.IMAGES.get(imageId);
            if (r2Object) {
              imageExists = true;
              console.log(`âœ“ Image already exists: ${liver.name}`);
            }
          } catch (e) {
            // ç”»åƒãŒå­˜åœ¨ã—ãªã„ï¼ˆæ­£å¸¸ï¼‰
          }
          
          if (imageExists) {
            results.push({
              liverName: liver.name,
              status: 'already_exists',
              imageUrl: `/api/images/${imageId}`
            });
            continue;
          }
          
          // ç”»åƒã‚’å–å¾—ã—ã¦ä¿å­˜
          try {
            let originalImageUrl = null;
            if (liver.profileImages && liver.profileImages.length > 0) {
              originalImageUrl = liver.profileImages[0].originalUrl;
            }
            
            if (!originalImageUrl) {
              throw new Error('No image URL available');
            }
            
            console.log(`ğŸ“¥ Fetching image: ${liver.name}`);
            const imageResponse = await fetch(originalImageUrl, {
              headers: {
                'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36',
                'Accept': 'image/avif,image/webp,image/apng,image/svg+xml,image/*,*/*;q=0.8',
                'Accept-Language': 'ja,en-US;q=0.9,en;q=0.8',
                'Cache-Control': 'no-cache'
              }
            });
            subrequestCount++;
            
            if (imageResponse.ok) {
              const imageBuffer = await imageResponse.arrayBuffer();
              const contentType = imageResponse.headers.get('content-type');
              
              if (imageBuffer.byteLength > 0) {
                // æ°¸ç¶šçš„ãªä¿å­˜ï¼ˆã‚¤ãƒ³ãƒ©ã‚¤ãƒ³ï¼‰
                await env.IMAGES.put(imageId, imageBuffer, {
                  httpMetadata: { 
                    contentType: contentType || 'image/jpeg',
                    cacheControl: 'public, max-age=31536000',
                  },
                  customMetadata: {
                    'liver-id': liver.id,
                    'upload-time': new Date().toISOString(),
                    'source': 'inline-scraper',
                    'permanent': 'true'
                  }
                });
                
                // KVã«ã‚‚è¨˜éŒ²
                if (env.IMAGE_HASHES) {
                  await env.IMAGE_HASHES.put(`image_${liver.id}`, JSON.stringify({
                    imageId: imageId,
                    uploadTime: new Date().toISOString(),
                    size: imageBuffer.byteLength,
                    contentType: contentType || 'image/jpeg',
                    permanent: true
                  }));
                }
                
                console.log(`âœ… Saved: ${liver.name} (${imageBuffer.byteLength} bytes)`);
                permanentlySaved++;
                results.push({
                  liverName: liver.name,
                  status: 'newly_saved',
                  imageUrl: `/api/images/${imageId}`,
                  size: imageBuffer.byteLength
                });
              }
            } else {
              throw new Error(`HTTP ${imageResponse.status}`);
            }
            
            await sleep(1000);
            imagesProcessed++;
            
          } catch (error) {
            console.error(`âŒ Failed to save ${liver.name}:`, error);
            results.push({
              liverName: liver.name,
              status: 'failed',
              error: error.message
            });
            subrequestCount++;
          }
        }
        
        return new Response(JSON.stringify({
          success: true,
          message: 'Inline image fix completed',
          totalLivers: existingData.data.length,
          permanentlySaved: permanentlySaved,
          subrequestsUsed: subrequestCount,
          results: results
        }, null, 2), {
          headers: { 'Content-Type': 'application/json', ...corsHeaders }
        });
        
      } catch (error) {
        return new Response(JSON.stringify({
          success: false,
          error: error.message
        }), {
          status: 500,
          headers: { 'Content-Type': 'application/json', ...corsHeaders }
        });
      }
    }

    // ãƒ©ã‚¤ãƒãƒ¼ä¸€è¦§API
    if (url.pathname === '/api/livers') {
      try {
        const data = env.LIVER_DATA ? await env.LIVER_DATA.get('latest_data') : null;
        
        if (!data) {
          return new Response(JSON.stringify({
            data: [], 
            total: 0, 
            error: "No data found in storage",
            suggestion: "Run /full-scrape to collect data"
          }), {
            headers: { 
              'Content-Type': 'application/json',
              'Cache-Control': 'max-age=300',
              ...corsHeaders
            }
          });
        }
        
        // JSONãƒ‘ãƒ¼ã‚¹ã‚’å®‰å…¨ã«å®Ÿè¡Œ
        let parsedData;
        try {
          parsedData = JSON.parse(data);
        } catch (parseError) {
          return new Response(JSON.stringify({
            data: [], 
            total: 0, 
            error: "Data parsing failed",
            rawDataPreview: data.substring(0, 200)
          }), {
            headers: { 
              'Content-Type': 'application/json',
              ...corsHeaders
            }
          });
        }
        
        return new Response(JSON.stringify(parsedData), {
          headers: { 
            'Content-Type': 'application/json',
            'Cache-Control': 'max-age=3600',
            ...corsHeaders
          }
        });
        
      } catch (error) {
        return new Response(JSON.stringify({
          data: [], 
          total: 0, 
          error: error.message
        }), {
          status: 500,
          headers: { 
            'Content-Type': 'application/json',
            ...corsHeaders
          }
        });
      }
    }
    
    // ç”»åƒAPI
    if (url.pathname.startsWith('/api/images/')) {
      const imageId = url.pathname.split('/').pop();
      const image = env.IMAGES ? await env.IMAGES.get(imageId) : null;
      
      if (!image) {
        return new Response('Image not found', { status: 404 });
      }
      
      return new Response(image.body, {
        headers: { 
          'Content-Type': 'image/jpeg',
          'Cache-Control': 'max-age=86400',
          ...corsHeaders
        }
      });
    }
    
    // ã‚¨ãƒ©ãƒ¼æƒ…å ±API
    if (url.pathname === '/api/status') {
      const latestData = env.LIVER_DATA ? await env.LIVER_DATA.get('latest_data') : null;
      const lastError = env.LIVER_DATA ? await env.LIVER_DATA.get('last_error') : null;
      
      return new Response(JSON.stringify({
        status: 'running',
        lastUpdate: latestData ? JSON.parse(latestData).timestamp : null,
        lastError: lastError ? JSON.parse(lastError) : null
      }), {
        headers: { 'Content-Type': 'application/json', ...corsHeaders }
      });
    }
    
    return new Response(`
Liver Scraper API
=================

Endpoints:
- GET /api/livers           : Get all liver data
- GET /api/images/:id       : Get liver images
- GET /api/status           : Get scraper status
- GET /test                 : Test single liver extraction
- GET /manual-scrape        : ğŸ†• Manually trigger full scraping
- GET /scrape-status        : ğŸ†• Get detailed scraping status
- GET /debug-login-only     : Test login only
- GET /debug-list-parsing   : Test list page parsing

Usage: https://your-worker.workers.dev/api/livers
    `, {
      headers: { 'Content-Type': 'text/plain' }
    });
  }
};

// èªè¨¼ä»˜ãå…¨ãƒšãƒ¼ã‚¸ã‚¹ã‚¯ãƒ¬ã‚¤ãƒ”ãƒ³ã‚°
async function scrapeAllPagesWithAuthentication(env) {
  console.log('ğŸ”§ Environment check:', {
    hasLiverData: !!env.LIVER_DATA,
    hasImageHashes: !!env.IMAGE_HASHES,
    hasImages: !!env.IMAGES,
    envKeys: Object.keys(env)
  });
  
  const baseUrl = 'https://www.comisapolive.com/liver/list/?q=&collaboration=&achievements=&rank=&app=&follower1=&follower2=&since=&gender=&age1=&age2=&regist=&search=1';
  let allLivers = [];
  let currentPage = 1;
  let maxPages = null;
  
  // âœ… ãƒ­ã‚°ã‚¤ãƒ³å‡¦ç†ã‚’æœ€åˆã«å®Ÿè¡Œ
  console.log('ğŸ” Performing login...');
  const loginResult = await performRobustLogin(env);
  
  if (!loginResult.success) {
    throw new Error(`Login failed: ${loginResult.error}`);
  }
  
  console.log('âœ… Login successful');
  
  do {
    console.log(`ğŸ“„ Scraping page ${currentPage}...`);
    
    const pageUrl = currentPage === 1 ? baseUrl : `${baseUrl}&page=${currentPage}`;
    
    try {
      // âœ… èªè¨¼ä»˜ãã§ãƒšãƒ¼ã‚¸å–å¾—
      let response = await fetch(pageUrl, {
        headers: {
          'Cookie': loginResult.cookies,  // loginResult ãŒå®šç¾©ã•ã‚ŒãŸå¾Œ
          'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36',
          'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8',
          'Accept-Language': 'ja,en-US;q=0.9,en;q=0.8',
          'Referer': 'https://www.comisapolive.com/'
        }
      });
      
      console.log(`ğŸ“„ Page ${currentPage} response:`, {
        status: response.status,
        url: response.url,
        cookiesUsed: !!loginResult.cookies
      });
      
      // 500ã‚¨ãƒ©ãƒ¼ã®å ´åˆã¯ãƒªãƒˆãƒ©ã‚¤
      if (response.status === 500) {
        console.log(`âš ï¸ Server error on page ${currentPage}, retrying in 5 seconds...`);
        await sleep(5000);
        
        response = await fetch(pageUrl, {
          headers: {
            'Cookie': loginResult.cookies,
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36',
            'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8',
            'Accept-Language': 'ja,en-US;q=0.9,en;q=0.8',
            'Referer': 'https://www.comisapolive.com/'
          }
        });
      }

      if (!response.ok) {
        console.error(`Failed to fetch page ${currentPage}: ${response.status}`);
        break;
      }
      
      const html = await response.text();
      
      // æ®‹ã‚Šã®å‡¦ç†ã¯æ—¢å­˜ã®ã¾ã¾...
      if (maxPages === null) {
        maxPages = getMaxPages(html);
        console.log(`ğŸ“Š Total pages detected: ${maxPages}`);
      }
      
      const pageData = await parseHTMLPageWithDetails(html, env, currentPage);
      
      if (pageData.length === 0) {
        console.log(`No data found on page ${currentPage}, stopping`);
        break;
      }
      
      // è©³ç´°æƒ…å ±å–å¾—å‡¦ç†...
      for (const liver of pageData) {
        if (liver.detailUrl) {
          console.log(`ğŸ” Fetching detailed info for: ${liver.name}`);
          const detailInfo = await scrapeDetailPageWithAuth(liver.detailUrl, loginResult.cookies, env);
          Object.assign(liver, detailInfo);
          
          if (detailInfo.profileInfo && detailInfo.profileInfo.gender) {
            console.log(`ğŸ‘¤ Gender found for ${liver.name}: ${detailInfo.profileInfo.gender}`);
          }
          
          // ç”»åƒã‚’è‡ªå‹•åé›†
          if (liver.profileImages && liver.profileImages.length > 0) {
            console.log(`ğŸ“¸ Auto-collecting image for: ${liver.name}`);
            try {
              await autoCollectAndStoreImage(liver, env);
            } catch (imageError) {
              console.error(`âŒ Image collection failed for ${liver.name}:`, imageError.message);
            }
          }
          
          await sleep(1000);
        }
      }
      
      allLivers = allLivers.concat(pageData);
      console.log(`âœ… Page ${currentPage}: ${pageData.length} livers processed (Total: ${allLivers.length})`);
      
      if (currentPage < maxPages) {
        await sleep(2000);
      }
      
      currentPage++;
      
    } catch (error) {
      console.error(`Error scraping page ${currentPage}:`, error);
      break;
    }
    
  } while (currentPage <= maxPages);
  
  console.log(`ğŸ‰ Total livers collected: ${allLivers.length}`);
  return allLivers;
}

// è‡ªå‹•ç”»åƒåé›†ãƒ»ä¿å­˜é–¢æ•°
async function autoCollectAndStoreImage(liver, env) {
  if (!env.IMAGES || !env.IMAGE_HASHES) {
    console.log(`âš ï¸ Storage bindings not available for ${liver.name}`);
    return;
  }

  const liverId = liver.id;
  const imageId = `${liverId}.jpg`;
  
  // æ—¢ã«ä¿å­˜æ¸ˆã¿ã‹ãƒã‚§ãƒƒã‚¯
  try {
    const existingImage = await env.IMAGES.get(imageId);
    if (existingImage) {
      console.log(`ğŸ“¸ Image already exists for ${liver.name}, skipping`);
      return;
    }
  } catch (error) {
    console.log(`ğŸ“¸ Checking existing image failed, proceeding with collection`);
  }

  // profileImagesã‹ã‚‰URLã‚’å–å¾—
  let imageUrl = null;
  if (liver.profileImages && liver.profileImages.length > 0) {
    imageUrl = liver.profileImages[0].originalUrl;
  }

  if (!imageUrl) {
    console.log(`ğŸ“¸ No image URL available for ${liver.name}`);
    return;
  }

  try {
    console.log(`ğŸ“¥ Downloading image from: ${imageUrl}`);
    const imageResponse = await fetch(imageUrl, {
      headers: {
        'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36',
        'Accept': 'image/avif,image/webp,image/apng,image/svg+xml,image/*,*/*;q=0.8',
        'Accept-Language': 'ja,en-US;q=0.9,en;q=0.8',
        'Referer': 'https://www.comisapolive.com/',
        'Sec-Fetch-Dest': 'image',
        'Sec-Fetch-Mode': 'no-cors',
        'Sec-Fetch-Site': 'same-origin'
      }
    });

    if (!imageResponse.ok) {
      throw new Error(`HTTP ${imageResponse.status}: ${imageResponse.statusText}`);
    }

    const imageBuffer = await imageResponse.arrayBuffer();
    if (imageBuffer.byteLength === 0) {
      throw new Error('Empty image data received');
    }

    // R2ã«ä¿å­˜
    await env.IMAGES.put(imageId, imageBuffer, {
      httpMetadata: { 
        contentType: imageResponse.headers.get('content-type') || 'image/jpeg',
        cacheControl: 'public, max-age=31536000'
      }
    });

    // ãƒãƒƒã‚·ãƒ¥ã‚‚ä¿å­˜
    const imageHash = generateHash(new Uint8Array(imageBuffer));
    await env.IMAGE_HASHES.put(`hash_${liverId}`, imageHash);

    console.log(`âœ… Auto-collected image for ${liver.name}: ${imageId} (${imageBuffer.byteLength} bytes)`);
    
  } catch (error) {
    console.error(`âŒ Auto-collect failed for ${liver.name}:`, error.message);
    throw error;
  }
}

// å …ç‰¢ãªãƒ­ã‚°ã‚¤ãƒ³å‡¦ç†
async function performRobustLogin(env) {
  try {
    console.log('ğŸ” Starting login process...');
    
    // 1. ãƒ­ã‚°ã‚¤ãƒ³ãƒšãƒ¼ã‚¸ã‚’å–å¾—
    const loginPageResponse = await fetch('https://www.comisapolive.com/login/', {
      headers: {
        'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
        'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8',
        'Accept-Language': 'ja,en-US;q=0.9,en;q=0.8'
      }
    });
    
    if (!loginPageResponse.ok) {
      return { success: false, error: `Login page failed: ${loginPageResponse.status}` };
    }
    
    const loginPageHtml = await loginPageResponse.text();
    const loginPageCookies = loginPageResponse.headers.get('set-cookie') || '';
    
    // 2. ãƒ•ã‚©ãƒ¼ãƒ æƒ…å ±ã‚’æŠ½å‡º
    const csrfToken = extractCSRFToken(loginPageHtml);
    const hiddenFields = extractHiddenFields(loginPageHtml);
    const actionUrl = extractFormAction(loginPageHtml) || 'https://www.comisapolive.com/login/';
    
    console.log('ğŸ“ Form analysis complete:', {
      csrf: !!csrfToken,
      hidden: Object.keys(hiddenFields).length,
      action: actionUrl.includes('login')
    });
    
    // 3. ãƒ­ã‚°ã‚¤ãƒ³ãƒ‡ãƒ¼ã‚¿ã‚’æº–å‚™
    const loginData = new URLSearchParams();
    
    // ç’°å¢ƒå¤‰æ•°ã‹ã‚‰èªè¨¼æƒ…å ±ã‚’å–å¾—ï¼ˆfallbackä»˜ãï¼‰
    const email = env.LOGIN_ID || 'comisapolive@gmail.com';
    const password = env.LOGIN_PASSWORD || 'cord3cord3';
    
    // è¤‡æ•°ã®ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰åãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’è©¦è¡Œ
    const emailFields = ['email', 'username', 'login_id', 'user_email', 'mail'];
    const passwordFields = ['password', 'passwd', 'pass', 'login_password'];
    
    emailFields.forEach(field => {
      loginData.append(field, email);
    });
    
    passwordFields.forEach(field => {
      loginData.append(field, password);
    });
    
    // CSRFå¯¾å¿œ
    if (csrfToken) {
      const csrfFields = ['csrf_token', '_token', 'authenticity_token', 'csrfmiddlewaretoken'];
      csrfFields.forEach(field => {
        loginData.append(field, csrfToken);
      });
    }
    
    // hidden ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰è¿½åŠ 
    Object.entries(hiddenFields).forEach(([name, value]) => {
      loginData.append(name, value);
    });
    
    // 4. ãƒ­ã‚°ã‚¤ãƒ³å®Ÿè¡Œ
    const loginResponse = await fetch(actionUrl, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/x-www-form-urlencoded',
        'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36',
        'Referer': 'https://www.comisapolive.com/login/',
        'Origin': 'https://www.comisapolive.com',
        'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8',
        'Cookie': loginPageCookies
      },
      body: loginData.toString(),
      redirect: 'manual'
    });
    
    const loginResponseCookies = loginResponse.headers.get('set-cookie') || '';
	const allCookies = combineCookies(loginPageCookies, loginResponseCookies);

	// ãƒ‡ãƒãƒƒã‚°æƒ…å ±ã‚’è¿½åŠ 
	console.log('ğŸ” Login response analysis:', {
	status: loginResponse.status,
	url: loginResponse.url,
	hasSetCookie: !!loginResponseCookies,
	cookieLength: loginResponseCookies.length,
	totalCookieLength: allCookies.length
	});

	// 5. æˆåŠŸåˆ¤å®š
	let success = false;
	let method = '';
    
    // ãƒªãƒ€ã‚¤ãƒ¬ã‚¯ãƒˆåˆ¤å®š
    if (loginResponse.status >= 300 && loginResponse.status < 400) {
	const location = loginResponse.headers.get('location');
	console.log('ğŸ“ Redirect detected:', { 
		location, 
		hasLogin: location?.includes('login'),
		hasError: location?.includes('error')
	});
	
	if (location && !location.includes('login') && !location.includes('error')) {
		success = true;
		method = 'redirect';
	}
	}
    
    // ãƒ¬ã‚¹ãƒãƒ³ã‚¹å†…å®¹åˆ¤å®š
	if (!success) {
	const loginResponseText = await loginResponse.text();
	console.log('ğŸ“„ Response preview (first 300 chars):', loginResponseText.substring(0, 300));
	console.log('ğŸ“Š Response length:', loginResponseText.length);
	
	const successPatterns = ['dashboard', 'ãƒã‚¤ãƒšãƒ¼ã‚¸', 'ãƒ­ã‚°ã‚¢ã‚¦ãƒˆ', 'menu', 'profile', 'liver', 'è¨­å®š', 'ãƒ›ãƒ¼ãƒ ', 'ã‚¢ã‚«ã‚¦ãƒ³ãƒˆ'];
	const failurePatterns = ['ãƒ­ã‚°ã‚¤ãƒ³ã«å¤±æ•—', 'ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ãŒé–“é•', 'èªè¨¼ã«å¤±æ•—', 'error', 'ã‚¨ãƒ©ãƒ¼', 'ãƒ­ã‚°ã‚¤ãƒ³ç”»é¢', 'ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰', 'ãƒ¡ãƒ¼ãƒ«ã‚¢ãƒ‰ãƒ¬ã‚¹'];
	
	const hasSuccess = successPatterns.some(pattern => 
		loginResponseText.toLowerCase().includes(pattern.toLowerCase())
	);
	const hasFailure = failurePatterns.some(pattern => 
		loginResponseText.toLowerCase().includes(pattern.toLowerCase())
	);
	
	console.log('ğŸ¯ Pattern matching:', { 
		hasSuccess, 
		hasFailure,
		foundSuccess: successPatterns.filter(p => loginResponseText.toLowerCase().includes(p.toLowerCase())),
		foundFailure: failurePatterns.filter(p => loginResponseText.toLowerCase().includes(p.toLowerCase()))
	});
	
	if (hasSuccess && !hasFailure) {
		success = true;
		method = 'content';
	}
	}
    
    // Cookieåˆ¤å®š
    if (!success && allCookies.length > loginPageCookies.length) {
      const sessionPatterns = ['session', 'auth', 'login', 'token', 'user'];
      const hasSessionCookie = sessionPatterns.some(pattern =>
        allCookies.toLowerCase().includes(pattern)
      );
      
      if (hasSessionCookie) {
        success = true;
        method = 'cookie';
      }
    }

	// ã‚ˆã‚Šç·©ã„æˆåŠŸåˆ¤å®šï¼ˆæœ€å¾Œã®æ‰‹æ®µï¼‰
	if (!success && loginResponse.status === 200) {
	const loginResponseText = await loginResponse.text();
	// ãƒ­ã‚°ã‚¤ãƒ³ãƒšãƒ¼ã‚¸ã®ç‰¹å¾´ãŒãªã„å ´åˆã¯æˆåŠŸã¨ã¿ãªã™
	if (!loginResponseText.includes('ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰') && 
		!loginResponseText.includes('ãƒ­ã‚°ã‚¤ãƒ³') && 
		loginResponseText.length > 1000) {
		success = true;
		method = 'fallback';
		console.log('ğŸ² Using fallback success detection - no login indicators found');
	}
	}
    
    console.log(`ğŸ” Login result: ${success ? 'âœ… SUCCESS' : 'âŒ FAILED'} (${method})`);
    
    return {
      success,
      cookies: allCookies,
      method,
      error: success ? null : 'Login failed - no success indicators found'
    };
    
  } catch (error) {
    console.error('Login error:', error);
    return {
      success: false,
      error: error.message
    };
  }
}

// èªè¨¼ä»˜ãè©³ç´°ãƒšãƒ¼ã‚¸ã‚¹ã‚¯ãƒ¬ã‚¤ãƒ”ãƒ³ã‚°
async function scrapeDetailPageWithAuth(detailUrl, cookies, env) {
  try {
    console.log(`ğŸ” Accessing detail page: ${detailUrl}`);
    console.log(`ğŸª Using cookies (length: ${cookies.length})`);
    
    const response = await fetch(detailUrl, {
      headers: {
        'Cookie': cookies,
        'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36',
        'Referer': 'https://www.comisapolive.com/', // ã‚ˆã‚Šå…·ä½“çš„ãªReferer
        'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8',
        'Accept-Language': 'ja,en-US;q=0.9,en;q=0.8',
        'Accept-Encoding': 'gzip, deflate, br',
        'Connection': 'keep-alive',
        'Upgrade-Insecure-Requests': '1'
      }
    });
    
    console.log(`ğŸ“„ Detail response: ${response.status} -> ${response.url}`);
    
    if (!response.ok) {
      console.error(`Failed to fetch detail page: ${response.status}`);
      return { error: `HTTP ${response.status}` };
    }
    
    const html = await response.text();
    
    // ãƒ­ã‚°ã‚¤ãƒ³ãŒå¿…è¦ã‹ãƒã‚§ãƒƒã‚¯
    if (html.includes('ãƒ­ã‚°ã‚¤ãƒ³') || response.url.includes('login')) {
      console.log('âš ï¸ Authentication expired, detail page requires login');
      return { requiresLogin: true };
    }
    
    const detailInfo = {};
    
    // å…¨ã¦ã®è©³ç´°æƒ…å ±ã‚’æŠ½å‡º
    try {
      // ã‚«ãƒ†ã‚´ãƒªï¼šliverProf_tag
      const categories = extractTextFromClass(html, 'liverProf_tag');
      if (categories.length > 0) detailInfo.categories = categories;
      
      // ãƒ©ã‚¤ãƒãƒ¼åï¼šliverProf_name
      const detailName = extractTextFromClass(html, 'liverProf_name');
      if (detailName.length > 0) detailInfo.detailName = detailName[0];
      
      // ãƒ•ã‚©ãƒ­ãƒ¯ãƒ¼æ•°ï¼šliverProf_follwer
      const detailFollowers = extractTextFromClass(html, 'liverProf_follwer');
      if (detailFollowers.length > 0) detailInfo.detailFollowers = detailFollowers[0];
      
      // ãƒ—ãƒ­ãƒ•ã‚£ãƒ¼ãƒ«ç”»åƒï¼šliverImage_views
      const profileImages = await extractImagesFromClass(html, 'liverImage_views', env);
      if (profileImages.length > 0) detailInfo.profileImages = profileImages;
      
      // ã‚³ãƒ©ãƒœé…ä¿¡OKï¼šliverProf_collaboOK
      const collaboOK = extractTextFromClass(html, 'liverProf_collaboOK');
      if (collaboOK.length > 0) detailInfo.collaboOK = collaboOK[0];
      
      // ã‚³ãƒ©ãƒœé…ä¿¡NGï¼šliverProf_collaboNG
      const collaboNG = extractTextFromClass(html, 'liverProf_collaboNG');
      if (collaboNG.length > 0) detailInfo.collaboNG = collaboNG[0];
      
      // å„åª’ä½“ãƒªãƒ³ã‚¯ï¼šliverProf_info
      const mediaLinks = extractLinksFromClass(html, 'liverProf_info');
      if (mediaLinks.length > 0) detailInfo.mediaLinks = mediaLinks;
      
      // ãƒ—ãƒ­ãƒ•ã‚£ãƒ¼ãƒ«æƒ…å ±ï¼ˆæ€§åˆ¥ã€é…ä¿¡æ­´ã€ç”Ÿå¹´æœˆæ—¥ï¼‰ï¼šliverProf_prof
      const profileTexts = extractTextFromClass(html, 'liverProf_prof');
      if (profileTexts.length > 0) {
        detailInfo.profileInfo = parseProfileInfo(profileTexts);
        detailInfo.rawProfileTexts = profileTexts; // ãƒ‡ãƒãƒƒã‚°ç”¨
      }
      
      // ã‚¤ãƒ™ãƒ³ãƒˆæƒ…å ±ï¼šliverEvent_scheduleTxt
      const eventInfo = extractTextFromClass(html, 'liverEvent_scheduleTxt');
      if (eventInfo.length > 0) detailInfo.eventInfo = eventInfo;
      
      // ãƒ©ã‚¤ãƒãƒ¼ã‚³ãƒ¡ãƒ³ãƒˆï¼šliverComment_body
      const comments = extractTextFromClass(html, 'liverComment_body');
      if (comments.length > 0) detailInfo.comments = comments;
      
      // é…ä¿¡åª’ä½“ãƒ»URLãƒ»ç™»éŒ²è€…æ•°ï¼šschedules_name, schedules_id, schedules_follwer
      const scheduleInfo = extractScheduleInfo(html);
      if (scheduleInfo.length > 0) detailInfo.schedules = scheduleInfo;
      
      // æ€§åˆ¥ãƒ‡ãƒ¼ã‚¿ã®ç‰¹åˆ¥æ¤œç´¢
      const genderSearch = findGenderData(html);
      if (genderSearch.found) {
        detailInfo.genderSearchResults = genderSearch;
        if (!detailInfo.profileInfo) detailInfo.profileInfo = {};
        if (!detailInfo.profileInfo.gender && genderSearch.bestMatch) {
          detailInfo.profileInfo.gender = genderSearch.bestMatch;
        }
      }
      
    } catch (extractError) {
      console.error('Detail extraction error:', extractError);
      detailInfo.extractionError = extractError.message;
    }
    
    return detailInfo;
    
  } catch (error) {
    console.error(`Error scraping detail page ${detailUrl}:`, error);
    return { error: error.message };
  }
}

// ãƒ†ã‚¹ãƒˆç”¨å˜ä¸€ãƒ©ã‚¤ãƒãƒ¼æŠ½å‡º
async function testSingleLiverWithGender(env) {
  const result = {
    step: '',
    success: false,
    error: null,
    liverData: null,
    genderFound: false
  };
  
  try {
    result.step = 'Performing login';
    const loginResult = await performRobustLogin(env);
    
    if (!loginResult.success) {
      throw new Error(`Login failed: ${loginResult.error}`);
    }
    
    console.log('Test: Login successful, cookies:', loginResult.cookies);
    
    result.step = 'Fetching list page with authentication';
    
    // âœ… èªè¨¼ä»˜ãã§ä¸€è¦§ãƒšãƒ¼ã‚¸ã‚’å–å¾—ï¼ˆscheduledå‡¦ç†ã¨åŒã˜æ–¹æ³•ï¼‰
    const listResponse = await fetch('https://www.comisapolive.com/liver/list/?q=&collaboration=&achievements=&rank=&app=&follower1=&follower2=&since=&gender=&age1=&age2=&regist=&search=1', {
      headers: {
        'Cookie': loginResult.cookies,
        'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36',
        'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8',
        'Accept-Language': 'ja,en-US;q=0.9,en;q=0.8',
        'Referer': 'https://www.comisapolive.com/'
      }
    });
    
    const listHtml = await listResponse.text();
    console.log('Test: List page response status:', listResponse.status);
    console.log('Test: List page HTML length:', listHtml.length);
    console.log('Test: List page contains liver class:', listHtml.includes('livers_item'));
    
    const pageData = await parseHTMLPageWithDetails(listHtml, env, 1);
    console.log('Test: Parsed liver count:', pageData.length);
    
    if (pageData.length === 0) {
      throw new Error('No liver data found in list page');
    }
    
    result.step = 'Extracting detail information';
    const targetLiver = pageData[0];
    console.log('Test: Target liver:', targetLiver.name, targetLiver.detailUrl);
    
    // âœ… å®Ÿéš›ã®è©³ç´°ãƒšãƒ¼ã‚¸URLï¼ˆ/liver/detail/ID/ å½¢å¼ï¼‰
    const actualDetailUrl = `https://www.comisapolive.com/liver/detail/${targetLiver.originalId}/`;
    console.log('Test: Accessing detail URL:', actualDetailUrl);
    
    const detailInfo = await scrapeDetailPageWithAuth(actualDetailUrl, loginResult.cookies, env);
    console.log('Test: Detail info keys:', Object.keys(detailInfo));
    
    Object.assign(targetLiver, detailInfo);
    
    result.liverData = targetLiver;
    result.genderFound = !!(detailInfo.profileInfo && detailInfo.profileInfo.gender);
    result.success = true;
    result.step = 'Complete';
    
  } catch (error) {
    console.error('Test error:', error);
    result.error = error.message;
  }
  
  return new Response(JSON.stringify(result, null, 2), {
    headers: { 'Content-Type': 'application/json' }
  });
}

// è©³ç´°ãƒšãƒ¼ã‚¸ã®HTMLã‚’è§£æï¼ˆè©³ç´°ãƒªãƒ³ã‚¯ä»˜ãï¼‰
// ğŸ”§ ä¿®æ­£ç‰ˆ: å®Ÿéš›ã®ã‚µã‚¤ãƒˆæ§‹é€ ã«å¯¾å¿œã—ãŸHTMLãƒ‘ãƒ¼ã‚¹å‡¦ç†
async function parseHTMLPageWithDetails(html, env, pageNumber) {
  const livers = [];
  
  console.log(`ğŸ” Enhanced parsing page ${pageNumber}, HTML length: ${html.length}`);
  
  // ğŸ†• å®Ÿéš›ã®ã‚µã‚¤ãƒˆæ§‹é€ ã«åŸºã¥ã„ãŸæ­£ã—ã„ãƒ‘ã‚¿ãƒ¼ãƒ³
  
  // 1. ã¾ãš /liver/detail/ ãƒªãƒ³ã‚¯ã‚’å…¨ã¦æŠ½å‡º
  const detailLinks = [];
  const linkPattern = /<a[^>]*href="(\/liver\/detail\/(\d+)\/?)"/g;
  let linkMatch;
  
  while ((linkMatch = linkPattern.exec(html)) !== null) {
    detailLinks.push({
      path: linkMatch[1],
      id: linkMatch[2],
      fullUrl: `https://www.comisapolive.com/liver/detail/${linkMatch[2]}/`
    });
  }
  
  console.log(`ğŸ”— Found ${detailLinks.length} detail links`);
  
  // 2. user_files_thumbnailç”»åƒã‹ã‚‰ãƒ©ã‚¤ãƒãƒ¼æƒ…å ±ã‚’æŠ½å‡º
  const imagePattern = /<img src="\/user_files_thumbnail\/(\d+)\/[^"]*" alt="([^"]*)"[^>]*>/g;
  const foundLivers = [];
  let imageMatch;
  
  while ((imageMatch = imagePattern.exec(html)) !== null) {
    const [fullMatch, id, name] = imageMatch;
    
    console.log(`ğŸ“¸ Found liver image: ${name} (ID: ${id})`);
    
    // å¯¾å¿œã™ã‚‹è©³ç´°ãƒªãƒ³ã‚¯ã‚’æ¢ã™
    const correspondingLink = detailLinks.find(link => link.id === id);
    
    if (correspondingLink) {
      foundLivers.push({
        id: id,
        name: name.trim(),
        imageUrl: fullMatch.match(/src="([^"]*)"/)[1],
        detailUrl: correspondingLink.fullUrl
      });
    }
  }
  
  // 3. ã‚ˆã‚Šè©³ç´°ãªæƒ…å ±æŠ½å‡ºï¼ˆãƒ•ã‚©ãƒ­ãƒ¯ãƒ¼æ•°ãªã©ï¼‰
  // livers_itemè¦ç´ ã‹ã‚‰è©³ç´°æƒ…å ±ã‚’æŠ½å‡º
  const itemPattern = /<div[^>]*class="[^"]*livers_item[^"]*"[^>]*>([\s\S]*?)<\/div>/g;
  let itemMatch;
  let itemIndex = 0;
  
  while ((itemMatch = itemPattern.exec(html)) !== null && itemIndex < foundLivers.length) {
    const itemHtml = itemMatch[1];
    const liver = foundLivers[itemIndex];
    
    if (liver) {
      // ãƒ•ã‚©ãƒ­ãƒ¯ãƒ¼æ•°ã‚’æŠ½å‡º
      const followerMatch = itemHtml.match(/<dd[^>]*>([^<]*)<\/dd>/);
      if (followerMatch) {
        const followerText = followerMatch[1].trim();
        liver.followers = parseInt(followerText.replace(/[,\s]/g, '')) || 0;
      }
      
      // ãƒ—ãƒ©ãƒƒãƒˆãƒ•ã‚©ãƒ¼ãƒ æƒ…å ±ã‚’æŠ½å‡º
      const platformMatch = itemHtml.match(/<dt[^>]*>([^<]*)<\/dt>/);
      if (platformMatch) {
        liver.platform = platformMatch[1].replace('ãƒ•ã‚©ãƒ­ãƒ¯ãƒ¼', '').trim();
      }
      
      // ãƒ©ã‚¤ãƒãƒ¼åã®å†ç¢ºèªï¼ˆlivers_name ã‚¯ãƒ©ã‚¹ã‹ã‚‰ï¼‰
      const nameMatch = itemHtml.match(/<p[^>]*class="[^"]*livers_name[^"]*"[^>]*>([^<]*)<\/p>/);
      if (nameMatch && nameMatch[1].trim()) {
        liver.name = nameMatch[1].trim();
      }
    }
    
    itemIndex++;
  }
  
  console.log(`ğŸ“Š Detailed parsing results: ${foundLivers.length} livers with details`);
  
  // 4. æœ€çµ‚çš„ãªãƒ©ã‚¤ãƒãƒ¼ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ä½œæˆ
  for (const liver of foundLivers) {
    const liverId = generateId(liver.name, pageNumber);
    const fullImageUrl = liver.imageUrl.startsWith('/') 
      ? `https://www.comisapolive.com${liver.imageUrl}` 
      : liver.imageUrl;
    
    // åŸºæœ¬ç”»åƒã®ä¿å­˜
    await saveImageIfChanged(env, liverId, fullImageUrl);
    
    livers.push({
      id: liverId,
      originalId: liver.id,
      name: liver.name,
      platform: liver.platform || 'Unknown',
      followers: liver.followers || 0,
      imageUrl: `/api/images/${liverId}.jpg`,
      detailUrl: liver.detailUrl,
      page: pageNumber,
      updatedAt: Date.now()
    });
    
    console.log(`âœ… Processed liver: ${liver.name} (${liver.platform}: ${liver.followers} followers)`);
  }
  
  console.log(`âœ… Page ${pageNumber} final result: ${livers.length} livers processed`);
  return livers;
}

// æ€§åˆ¥ãƒ‡ãƒ¼ã‚¿ã®åŒ…æ‹¬çš„æ¤œç´¢
function findGenderData(html) {
  const genderInfo = {
    found: false,
    matches: [],
    methods: [],
    bestMatch: null
  };
  
  try {
    // æ–¹æ³•1: ç›´æ¥çš„ãªæ€§åˆ¥è¡¨è¨˜ã‚’æ¤œç´¢
    const directPatterns = [
      /æ€§åˆ¥[:\s]*([^\s<\n]{1,10})/gi,
      /Gender[:\s]*([^\s<\n]{1,10})/gi,
      /(ç”·æ€§|å¥³æ€§|ãã®ä»–|male|female|other)/gi
    ];
    
    directPatterns.forEach((pattern, index) => {
      const matches = html.match(pattern);
      if (matches) {
        genderInfo.matches.push(...matches);
        genderInfo.methods.push(`direct_pattern_${index + 1}`);
        genderInfo.found = true;
        
        // æœ€åˆã®æ˜ç¢ºãªæ€§åˆ¥ã‚’ä¿å­˜
        if (!genderInfo.bestMatch) {
          const cleanMatch = matches[0].replace(/æ€§åˆ¥[:\s]*/, '').replace(/Gender[:\s]*/, '').trim();
          if (cleanMatch.match(/(ç”·æ€§|å¥³æ€§|ãã®ä»–)/)) {
            genderInfo.bestMatch = cleanMatch;
          }
        }
      }
    });
    
    // æ–¹æ³•2: ãƒ—ãƒ­ãƒ•ã‚£ãƒ¼ãƒ«ã‚¯ãƒ©ã‚¹å†…ã®è©³ç´°æ¤œç´¢
    const profPattern = /class="[^"]*liverProf_prof[^"]*"[^>]*>([\s\S]*?)<\/[^>]+>/gi;
    let profMatch;
    
    while ((profMatch = profPattern.exec(html)) !== null) {
      const profContent = profMatch[1];
      const genderInProf = profContent.match(/(æ€§åˆ¥|ç”·æ€§|å¥³æ€§|Gender)/gi);
      if (genderInProf) {
        genderInfo.matches.push(...genderInProf);
        genderInfo.methods.push('profile_class_search');
        genderInfo.found = true;
        genderInfo.profileContext = profContent.replace(/<[^>]*>/g, '').trim();
      }
    }
    
  } catch (error) {
    genderInfo.error = error.message;
  }
  
  return genderInfo;
}

// ãƒ˜ãƒ«ãƒ‘ãƒ¼é–¢æ•°ç¾¤ï¼ˆæ—¢å­˜ã®ã‚‚ã®ã‚’å†åˆ©ç”¨ï¼‰
function extractTextFromClass(html, className) {
  const results = [];
  const patterns = [
    new RegExp(`<[^>]*class="[^"]*${className}[^"]*"[^>]*>([\\s\\S]*?)<\/[^>]+>`, 'gi'),
    new RegExp(`<div[^>]*class="[^"]*${className}[^"]*"[^>]*>([\\s\\S]*?)<\/div>`, 'gi'),
    new RegExp(`<span[^>]*class="[^"]*${className}[^"]*"[^>]*>([\\s\\S]*?)<\/span>`, 'gi'),
    new RegExp(`<p[^>]*class="[^"]*${className}[^"]*"[^>]*>([\\s\\S]*?)<\/p>`, 'gi')
  ];
  
  for (const pattern of patterns) {
    let match;
    while ((match = pattern.exec(html)) !== null) {
      let text = match[1]
        .replace(/<[^>]*>/g, '')
        .replace(/&nbsp;/g, ' ')
        .replace(/&amp;/g, '&')
        .replace(/&lt;/g, '<')
        .replace(/&gt;/g, '>')
        .replace(/\s+/g, ' ')
        .trim();
      
      if (text && text.length > 0) {
        results.push(text);
      }
    }
  }
  
  return [...new Set(results)];
}

async function extractImagesFromClass(html, className, env) {
  const results = [];
  const pattern = new RegExp(`<[^>]*class="[^"]*${className}[^"]*"[^>]*>([\\s\\S]*?)<\/[^>]+>`, 'g');
  let match;
  let imageIndex = 0;
  
  while ((match = pattern.exec(html)) !== null) {
    const imgPattern = /<img[^>]*src="([^"]*)"[^>]*>/g;
    let imgMatch;
    
    while ((imgMatch = imgPattern.exec(match[1])) !== null) {
      const imageUrl = imgMatch[1];
      const fullImageUrl = imageUrl.startsWith('/') 
        ? `https://www.comisapolive.com${imageUrl}` 
        : imageUrl;
      
      const imageId = `profile_${imageIndex}_${Date.now()}`;
      await saveImageIfChanged(env, imageId, fullImageUrl);
      
      results.push({
        url: `/api/images/${imageId}.jpg`,
        originalUrl: fullImageUrl
      });
      
      imageIndex++;
    }
  }
  
  return results;
}

function parseProfileInfo(profileTexts) {
  const info = {};
  
  for (const text of profileTexts) {
    const lowerText = text.toLowerCase();
    
    // ã‚ˆã‚ŠæŸ”è»Ÿãªæ€§åˆ¥åˆ¤å®š
    if (lowerText.includes('æ€§åˆ¥') || lowerText.includes('ç”·æ€§') || lowerText.includes('å¥³æ€§') || 
        lowerText.includes('gender') || lowerText.includes('male') || lowerText.includes('female')) {
      info.gender = text;
    } else if (lowerText.includes('é…ä¿¡æ­´') || (lowerText.includes('å¹´') && lowerText.includes('ãƒ¶æœˆ'))) {
      info.streamingHistory = text;
    } else if (lowerText.includes('ç”Ÿå¹´æœˆæ—¥') || (lowerText.includes('æœˆ') && lowerText.includes('æ—¥'))) {
      info.birthday = text;
    }
  }
  
  return info;
}

function extractScheduleInfo(html) {
  const schedules = [];
  
  // schedules_name, schedules_id, schedules_follwer ã‚’åŒæ™‚ã«æŠ½å‡º
  const schedulePattern = /<[^>]*class="[^"]*schedules_name[^"]*"[^>]*>([^<]*)<\/[^>]*>[\s\S]*?<[^>]*class="[^"]*schedules_id[^"]*"[^>]*href="([^"]*)"[^>]*>[\s\S]*?<[^>]*class="[^"]*schedules_follwer[^"]*"[^>]*>([^<]*)<\/[^>]*>/g;
  let match;
  
  while ((match = schedulePattern.exec(html)) !== null) {
    schedules.push({
      name: match[1].trim(),
      url: match[2],
      followers: match[3].trim()
    });
  }
  
  // å€‹åˆ¥ã«æŠ½å‡ºã™ã‚‹æ–¹æ³•ã‚‚ä½µç”¨
  if (schedules.length === 0) {
    const names = extractTextFromClass(html, 'schedules_name');
    const urls = extractLinksFromClass(html, 'schedules_id');
    const followers = extractTextFromClass(html, 'schedules_follwer');
    
    const maxLength = Math.max(names.length, urls.length, followers.length);
    for (let i = 0; i < maxLength; i++) {
      schedules.push({
        name: names[i] || '',
        url: urls[i]?.url || '',
        followers: followers[i] || ''
      });
    }
  }
  
  return schedules;
}

function getMaxPages(html) {
  const pagePattern = /[?&]page=(\d+)/g;
  let maxPage = 1;
  let match;
  
  while ((match = pagePattern.exec(html)) !== null) {
    const pageNum = parseInt(match[1]);
    if (pageNum > maxPage) {
      maxPage = pageNum;
    }
  }
  
  // ã‚ˆã‚Šç¢ºå®Ÿãªæ–¹æ³•ï¼šã€Œæ¬¡ã¸ã€ãƒœã‚¿ãƒ³ã‚„æœ€å¾Œã®ãƒšãƒ¼ã‚¸ãƒªãƒ³ã‚¯ã‚’æ¢ã™
  const nextPagePattern = /<a[^>]*href="[^"]*[?&]page=(\d+)"[^>]*>(?:æ¬¡|&gt;|Â»)/i;
  const nextMatch = nextPagePattern.exec(html);
  if (nextMatch) {
    const nextPage = parseInt(nextMatch[1]);
    maxPage = Math.max(maxPage, nextPage);
  }
  
  return maxPage;
}

async function saveImageIfChanged(env, liverId, imageUrl) {
  try {
    const headResponse = await fetch(imageUrl, { method: 'HEAD' });
    if (!headResponse.ok) return;
    
    const lastModified = headResponse.headers.get('last-modified') || '';
    const contentLength = headResponse.headers.get('content-length') || '';
    const currentHash = generateHash(lastModified + contentLength + imageUrl);
    
    const storedHash = env.IMAGE_HASHES ? await env.IMAGE_HASHES.get(`hash_${liverId}`) : null;
    
    if (currentHash !== storedHash) {
      const imageResponse = await fetch(imageUrl);
      if (imageResponse.ok) {
        const imageBuffer = await imageResponse.arrayBuffer();
        
        if (env.IMAGES) {
          await env.IMAGES.put(`${liverId}.jpg`, imageBuffer, {
            httpMetadata: { contentType: 'image/jpeg' }
          });
        }
        
        if (env.IMAGE_HASHES) {
          await env.IMAGE_HASHES.put(`hash_${liverId}`, currentHash);
        }
        console.log(`ğŸ“¸ Updated image for ${liverId}`);
      }
    }
  } catch (error) {
    console.error(`Failed to process image for ${liverId}:`, error);
  }
}

function generateId(name, pageNumber) {
  const baseName = name.toLowerCase()
    .replace(/[^\w\s]/g, '')
    .replace(/\s+/g, '_')
    .substring(0, 40);
  
  return `${baseName}_p${pageNumber}_${Date.now().toString().slice(-6)}`;
}

function generateHash(data) {
  let hash = 0;
  if (data.length === 0) return hash.toString();
  for (let i = 0; i < data.length; i++) {
    const char = data.charCodeAt(i);
    hash = ((hash << 5) - hash) + char;
    hash = hash & hash;
  }
  return hash.toString();
}

function sleep(ms) {
  return new Promise(resolve => setTimeout(resolve, ms));
}

function extractCSRFToken(html) {
  let match = html.match(/<meta[^>]*name=["\']csrf-token["\'][^>]*content=["\']([^"\']*)["\'][^>]*>/i);
  if (match) return match[1];
  
  match = html.match(/<meta[^>]*content=["\']([^"\']*)["\'][^>]*name=["\']csrf-token["\'][^>]*>/i);
  if (match) return match[1];
  
  match = html.match(/<input[^>]*name=["\']csrf_token["\'][^>]*value=["\']([^"\']*)["\'][^>]*>/i);
  if (match) return match[1];
  
  match = html.match(/<input[^>]*name=["\']_token["\'][^>]*value=["\']([^"\']*)["\'][^>]*>/i);
  if (match) return match[1];
  
  return null;
}

function extractHiddenFields(html) {
  const hiddenFields = {};
  const pattern = /<input[^>]*type=["\']hidden["\'][^>]*>/gi;
  let match;
  
  while ((match = pattern.exec(html)) !== null) {
    const input = match[0];
    const nameMatch = input.match(/name=["\']([^"\']*)["\']/i);
    const valueMatch = input.match(/value=["\']([^"\']*)["\']/i);
    
    if (nameMatch && valueMatch) {
      hiddenFields[nameMatch[1]] = valueMatch[1];
    }
  }
  
  return hiddenFields;
}

function extractFormAction(html) {
  const match = html.match(/<form[^>]*action=["\']([^"\']*)["\'][^>]*>/i);
  if (match) {
    const action = match[1];
    return action.startsWith('/') ? `https://www.comisapolive.com${action}` : action;
  }
  return null;
}

function combineCookies(cookies1, cookies2) {
  console.log('ğŸª Raw cookies1:', cookies1);
  console.log('ğŸª Raw cookies2:', cookies2);
  
  let finalCookies = '';
  
  if (cookies2 && cookies2.includes('SESS_PUBLISH')) {
    // cookies2ã‹ã‚‰æœ€æ–°ã®SESS_PUBLISHã‚’æŠ½å‡º
    const sessMatches = cookies2.match(/SESS_PUBLISH=([^;,]+)/g);
    if (sessMatches && sessMatches.length > 0) {
      // æœ€å¾Œã®ãƒãƒƒãƒã‚’ä½¿ç”¨
      finalCookies = sessMatches[sessMatches.length - 1];
      console.log('ğŸª Using latest SESS_PUBLISH:', finalCookies);
    }
  } else if (cookies1 && cookies1.includes('SESS_PUBLISH')) {
    // cookies1ã‹ã‚‰æŠ½å‡º
    const sessMatch = cookies1.match(/SESS_PUBLISH=([^;,]+)/);
    if (sessMatch) {
      finalCookies = `SESS_PUBLISH=${sessMatch[1]}`;
      console.log('ğŸª Using cookies1 SESS_PUBLISH:', finalCookies);
    }
  }
  
  return finalCookies;
}

function extractLinksFromClass(html, className) {
  const results = [];
  const pattern = new RegExp(`<[^>]*class="[^"]*${className}[^"]*"[^>]*>([\\s\\S]*?)<\/[^>]+>`, 'g');
  let match;
  
  while ((match = pattern.exec(html)) !== null) {
    const linkPattern = /<a[^>]*href="([^"]*)"[^>]*>([^<]*)<\/a>/g;
    let linkMatch;
    
    while ((linkMatch = linkPattern.exec(match[1])) !== null) {
      results.push({
        url: linkMatch[1],
        text: linkMatch[2].trim()
      });
    }
  }

  // æ°¸ç¶šçš„ãªç”»åƒä¿å­˜å‡¦ç†
async function saveImagePersistently(env, liverId, imageBuffer, contentType) {
  try {
    const imageId = `${liverId}.jpg`;
    
    // ã‚ˆã‚Šæ°¸ç¶šçš„ãªä¿å­˜ã‚ªãƒ—ã‚·ãƒ§ãƒ³
    await env.IMAGES.put(imageId, imageBuffer, {
      httpMetadata: { 
        contentType: contentType || 'image/jpeg',
        cacheControl: 'public, max-age=31536000', // 1å¹´é–“ã‚­ãƒ£ãƒƒã‚·ãƒ¥
      },
      customMetadata: {
        'liver-id': liverId,
        'upload-time': new Date().toISOString(),
        'source': 'auto-scraper',
        'permanent': 'true'
      }
    });
    
    // KVã«ã‚‚ç”»åƒã®å­˜åœ¨ã‚’è¨˜éŒ²ï¼ˆãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ï¼‰
    if (env.IMAGE_HASHES) {
      await env.IMAGE_HASHES.put(`image_${liverId}`, JSON.stringify({
        imageId: imageId,
        uploadTime: new Date().toISOString(),
        size: imageBuffer.byteLength,
        contentType: contentType || 'image/jpeg',
        permanent: true
      }));
    }
    
    console.log(`ğŸ’¾ Permanently saved image: ${imageId} (${imageBuffer.byteLength} bytes)`);
    return true;
    
  } catch (error) {
    console.error(`âŒ Failed to save image permanently:`, error);
    return false;
  }
}

// ç”»åƒã®å­˜åœ¨ç¢ºèªï¼ˆæ°¸ç¶šæ€§ãƒã‚§ãƒƒã‚¯ä»˜ãï¼‰
async function checkImageExists(env, liverId) {
  try {
    const imageId = `${liverId}.jpg`;
    
    // R2ã§ç›´æ¥ç¢ºèª
    const r2Object = await env.IMAGES.get(imageId);
    if (r2Object) {
      console.log(`âœ… Image exists in R2: ${imageId}`);
      return true;
    }
    
    // KVã§ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ç¢ºèª
    if (env.IMAGE_HASHES) {
      const backupInfo = await env.IMAGE_HASHES.get(`image_${liverId}`);
      if (backupInfo) {
        console.log(`ğŸ“‹ Image record exists in KV: ${imageId}`);
        return false; // R2ã«ã¯ãªã„ãŒKVã«è¨˜éŒ²ãŒã‚ã‚‹ï¼ˆè¦å†å–å¾—ï¼‰
      }
    }
    
    return false;
    
  } catch (error) {
    console.error(`âŒ Error checking image existence:`, error);
    return false;
  }
}
  
  return results;
}