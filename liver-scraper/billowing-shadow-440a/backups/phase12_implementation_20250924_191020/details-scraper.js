// Worker2: liver-scraper-details (Ë©≥Á¥∞ÊÉÖÂ†±Â∞ÇÈñÄ)
// ÂΩπÂâ≤: Ë©≥Á¥∞ÊÉÖÂ†±ÂèñÂæóÂ∞ÇÈñÄ
// Cron„Çπ„Ç±„Ç∏„É•„Éº„É´: "30 0,6,12,18 * * *" („É°„Ç§„É≥„ÅÆ30ÂàÜÂæå)

export default {
  async scheduled(event, env, ctx) {
    console.log('üîç Starting details scraper (Worker2) - Scheduled execution...');
    
    try {
      // Âü∫Êú¨„Éá„Éº„Çø„ÇíÂèñÂæó
      const basicDataStr = env.LIVER_DATA ? await env.LIVER_DATA.get('latest_basic_data') : null;
      if (!basicDataStr) {
        console.log('‚ÑπÔ∏è No basic data found, waiting for main worker...');
        return;
      }
      
      const basicData = JSON.parse(basicDataStr);
      const livers = basicData.data || [];
      
      if (livers.length === 0) {
        console.log('‚ÑπÔ∏è No livers to process');
        return;
      }
      
      // CPUÊôÇÈñìÂà∂ÈôêÂØæÁ≠ñÔºöÊúÄÈÅ©Âåñ„Åï„Çå„Åü„Éê„ÉÉ„ÉÅ„Çµ„Ç§„Ç∫„ÅßÊÆµÈöéÁöÑÂá¶ÁêÜ
      await processSmallBatch(env, livers, 15); // 15‰ª∂„Åö„Å§Âá¶ÁêÜÔºàÂÆâÂÖ®„Éû„Éº„Ç∏„É≥ËÄÉÊÖÆÔºâ
      
    } catch (error) {
      console.error('‚ùå Details scraper scheduled run failed:', error);
      await updateWorkerStatus(env, 'details', 'error', { error: error.message });
    }
  },

  async fetch(request, env) {
    const url = new URL(request.url);
    
    // CORSË®≠ÂÆö
    const corsHeaders = {
      'Access-Control-Allow-Origin': '*',
      'Access-Control-Allow-Methods': 'GET, POST, OPTIONS',
      'Access-Control-Allow-Headers': 'Content-Type, Authorization',
    };
    
    if (request.method === 'OPTIONS') {
      return new Response(null, { headers: corsHeaders });
    }
    
    // Ë™çË®º„ÉÅ„Çß„ÉÉ„ÇØ
    const authHeader = request.headers.get('Authorization');
    const expectedToken = env.WORKER_AUTH_TOKEN || 'default-token';
    if (authHeader !== `Bearer ${expectedToken}`) {
      return new Response('Unauthorized', { status: 401 });
    }

    // ÊâãÂãïË©≥Á¥∞Âá¶ÁêÜ„Ç®„É≥„Éâ„Éù„Ç§„É≥„Éà
    if (url.pathname === '/manual-details') {
      try {
        console.log('üöÄ Manual details processing triggered...');

        // Âü∫Êú¨„Éá„Éº„Çø„ÇíÂèñÂæó
        const basicDataStr = env.LIVER_DATA ? await env.LIVER_DATA.get('latest_basic_data') : null;
        if (!basicDataStr) {
          return new Response(JSON.stringify({
            success: false,
            error: 'No basic data found'
          }), {
            status: 400,
            headers: { ...corsHeaders, 'Content-Type': 'application/json' }
          });
        }

        const basicData = JSON.parse(basicDataStr);
        const livers = basicData.data || [];

        // ÊúÄÈÅ©Âåñ„Åï„Çå„Åü„Éê„ÉÉ„ÉÅ„ÅßÂá¶ÁêÜ
        await processSmallBatch(env, livers, 20); // ÊâãÂãïÂÆüË°å„Åß„ÅØÂ∞ë„ÅóÂ§ß„Åç„ÇÅ„ÅÆ„Éê„ÉÉ„ÉÅ

        return new Response(JSON.stringify({
          success: true,
          message: 'Manual details processing started',
          total: livers.length
        }), {
          headers: { ...corsHeaders, 'Content-Type': 'application/json' }
        });

      } catch (error) {
        console.error('‚ùå Manual details processing failed:', error);
        return new Response(JSON.stringify({
          success: false,
          error: error.message
        }), {
          status: 500,
          headers: { ...corsHeaders, 'Content-Type': 'application/json' }
        });
      }
    }

    // üîó schedules_id URLÊäΩÂá∫„ÉÜ„Çπ„Éà„Ç®„É≥„Éâ„Éù„Ç§„É≥„Éà
    if (url.pathname === '/test-schedules-id') {
      try {
        const targetId = url.searchParams.get('id') || '158'; // „Éá„Éï„Ç©„É´„Éà„ÉÜ„Çπ„ÉàID
        const testUrl = `https://www.comisapolive.com/liver/detail/${targetId}/`;
        
        console.log(`üß™ Testing schedules_id extraction for: ${testUrl}`);
        
        // „É≠„Ç∞„Ç§„É≥„Åó„Å¶Ë©≥Á¥∞„Éö„Éº„Ç∏„Å´„Ç¢„ÇØ„Çª„Çπ
        const loginResult = await performRobustLogin(env);
        if (!loginResult.success) {
          return new Response(JSON.stringify({
            success: false,
            error: 'Login failed',
            details: loginResult.error
          }), {
            status: 500,
            headers: { ...corsHeaders, 'Content-Type': 'application/json' }
          });
        }
        
        const response = await fetch(testUrl, {
          headers: {
            'Cookie': loginResult.cookies,
            'User-Agent': loginResult.userAgent || 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36',
            'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8'
          }
        });
        
        if (!response.ok) {
          return new Response(JSON.stringify({
            success: false,
            error: `HTTP ${response.status}`,
            url: testUrl
          }), {
            status: 400,
            headers: { ...corsHeaders, 'Content-Type': 'application/json' }
          });
        }
        
        const html = await response.text();
        
        // Êñ∞„Åó„ÅÑÈñ¢Êï∞„Çí„ÉÜ„Çπ„Éà
        const scheduleUrls = extractSchedulesIdUrls(html);
        const scheduleInfo = extractScheduleInfo(html); // Êó¢Â≠ò„ÅÆÈñ¢Êï∞„ÇÇÊØîËºÉ
        
        return new Response(JSON.stringify({
          success: true,
          testId: targetId,
          testUrl: testUrl,
          results: {
            newFunction: {
              count: scheduleUrls.length,
              urls: scheduleUrls
            },
            existingFunction: {
              count: scheduleInfo.length,
              schedules: scheduleInfo
            }
          },
          comparison: {
            newFunctionUrlsOnly: scheduleUrls.map(s => ({url: s.url, type: s.type})),
            existingFunctionUrls: scheduleInfo.map(s => s.url).filter(u => u && u !== '')
          }
        }), {
          headers: { ...corsHeaders, 'Content-Type': 'application/json' }
        });
        
      } catch (error) {
        return new Response(JSON.stringify({
          success: false,
          error: error.message,
          stack: error.stack
        }), {
          status: 500,
          headers: { ...corsHeaders, 'Content-Type': 'application/json' }
        });
      }
    }

    // Êñ∞„Ç∑„Çπ„ÉÜ„É†„ÅÆ„ÉÜ„Çπ„ÉàÂÆüË°å„Ç®„É≥„Éâ„Éù„Ç§„É≥„Éà
    if (url.pathname === '/test-new-system') {
      try {
        const basicDataStr = env.LIVER_DATA ? await env.LIVER_DATA.get('latest_basic_data') : null;
        if (!basicDataStr) {
          return new Response(JSON.stringify({
            success: false,
            error: 'No basic data available'
          }), {
            status: 400,
            headers: { ...corsHeaders, 'Content-Type': 'application/json' }
          });
        }
        
        const basicData = JSON.parse(basicDataStr);
        const livers = basicData.data || [];
        
        // Êñ∞„Ç∑„Çπ„ÉÜ„É†„Åß3‰ª∂Âá¶ÁêÜ
        await processSmallBatch(env, livers, 3);
        
        return new Response(JSON.stringify({
          success: true,
          message: 'New progressive system test completed',
          info: 'Check progress endpoint for details'
        }), {
          headers: { ...corsHeaders, 'Content-Type': 'application/json' }
        });
      } catch (error) {
        return new Response(JSON.stringify({
          success: false,
          error: error.message
        }), {
          status: 500,
          headers: { ...corsHeaders, 'Content-Type': 'application/json' }
        });
      }
    }

    // „Éá„Éê„ÉÉ„Ç∞„Ç®„É≥„Éâ„Éù„Ç§„É≥„Éà1: „É≠„Ç∞„Ç§„É≥Âá¶ÁêÜ„ÅÆ„Åø„Çí„ÉÜ„Çπ„Éà
    if (url.pathname === '/debug-login-only') {
      try {
        console.log('üß™ Debug: Testing login process only...');
        const loginResult = await performRobustLogin(env);
        
        return new Response(JSON.stringify({
          loginSuccess: loginResult.success,
          loginMethod: loginResult.method || 'none',
          cookiesLength: loginResult.cookies ? loginResult.cookies.length : 0,
          error: loginResult.error,
          timestamp: new Date().toISOString(),
          debugInfo: {
            envVars: {
              hasLoginId: !!env.LOGIN_EMAIL,
              hasLoginPassword: !!env.LOGIN_PASSWORD,
              loginIdDefault: env.LOGIN_EMAIL || 'using fallback: comisapolive@gmail.com',
              passwordDefault: env.LOGIN_PASSWORD || 'using fallback: cord3cord3'
            }
          }
        }), {
          headers: { ...corsHeaders, 'Content-Type': 'application/json' }
        });
      } catch (error) {
        return new Response(JSON.stringify({
          loginSuccess: false,
          error: error.message,
          stack: error.stack
        }), {
          status: 500,
          headers: { ...corsHeaders, 'Content-Type': 'application/json' }
        });
      }
    }

    // „Éá„Éê„ÉÉ„Ç∞„Ç®„É≥„Éâ„Éù„Ç§„É≥„Éà2: Ë™çË®ºÂæå„ÅÆ„É™„Çπ„ÉàËß£Êûê„Çí„ÉÜ„Çπ„Éà
    if (url.pathname === '/debug-list-parsing') {
      try {
        console.log('üß™ Debug: Testing authenticated list parsing...');
        const loginResult = await performRobustLogin(env);
        
        if (!loginResult.success) {
          return new Response(JSON.stringify({
            success: false,
            error: 'Login failed: ' + loginResult.error
          }), {
            status: 401,
            headers: { ...corsHeaders, 'Content-Type': 'application/json' }
          });
        }

        const listResponse = await fetch('https://www.comisapolive.com/liver/list/', {
          headers: {
            'Cookie': loginResult.cookies,
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36',
            'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8'
          }
        });

        const listHtml = await listResponse.text();
        const hasLoginForm = listHtml.includes('name="email"') || listHtml.includes('name="password"');
        const liverCount = (listHtml.match(/\/liver\/\d+\//g) || []).length;
        
        return new Response(JSON.stringify({
          success: !hasLoginForm,
          listResponseStatus: listResponse.status,
          hasLoginForm,
          liverLinksFound: liverCount,
          htmlLength: listHtml.length,
          sampleHtml: listHtml.substring(0, 500),
          cookieUsed: loginResult.cookies.substring(0, 100) + '...'
        }), {
          headers: { ...corsHeaders, 'Content-Type': 'application/json' }
        });
      } catch (error) {
        return new Response(JSON.stringify({
          success: false,
          error: error.message
        }), {
          status: 500,
          headers: { ...corsHeaders, 'Content-Type': 'application/json' }
        });
      }
    }

    // „Éá„Éê„ÉÉ„Ç∞„Ç®„É≥„Éâ„Éù„Ç§„É≥„Éà3: Ë™çË®º‰ªò„ÅçHTMLÂèñÂæó„Çí„ÉÜ„Çπ„Éà
    if (url.pathname === '/debug-html-auth') {
      try {
        console.log('üß™ Debug: Testing authenticated HTML fetch...');
        const loginResult = await performRobustLogin(env);
        
        if (!loginResult.success) {
          return new Response(JSON.stringify({
            success: false,
            error: 'Login failed: ' + loginResult.error
          }), {
            status: 401,
            headers: { ...corsHeaders, 'Content-Type': 'application/json' }
          });
        }

        // „ÉÜ„Çπ„ÉàÁî®„Å´ÊúÄÂàù„ÅÆ„É©„Ç§„Éê„Éº„Éö„Éº„Ç∏„Çí„ÉÜ„Çπ„Éà
        const testUrls = [
          'https://www.comisapolive.com/liver/list/',
          'https://www.comisapolive.com/liver/1/',
          'https://www.comisapolive.com/liver/2/'
        ];
        
        const results = [];
        for (const testUrl of testUrls) {
          try {
            const response = await fetch(testUrl, {
              headers: {
                'Cookie': loginResult.cookies,
                'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36',
                'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8'
              }
            });
            
            const html = await response.text();
            results.push({
              url: testUrl,
              status: response.status,
              hasLoginForm: html.includes('name="email"') || html.includes('name="password"'),
              htmlLength: html.length,
              title: (html.match(/<title>(.*?)<\/title>/i) || ['', 'No title'])[1]
            });
          } catch (err) {
            results.push({
              url: testUrl,
              error: err.message
            });
          }
        }
        
        return new Response(JSON.stringify({
          success: true,
          loginMethod: loginResult.method,
          cookieLength: loginResult.cookies.length,
          testResults: results
        }), {
          headers: { ...corsHeaders, 'Content-Type': 'application/json' }
        });
      } catch (error) {
        return new Response(JSON.stringify({
          success: false,
          error: error.message
        }), {
          status: 500,
          headers: { ...corsHeaders, 'Content-Type': 'application/json' }
        });
      }
    }

    // „Éá„Éê„ÉÉ„Ç∞„Ç®„É≥„Éâ„Éù„Ç§„É≥„Éà4: CookieÊÉÖÂ†±„ÅÆË©≥Á¥∞ÂàÜÊûê
    if (url.pathname === '/debug-cookies') {
      try {
        console.log('üß™ Debug: Analyzing cookie information...');
        
        // „É≠„Ç∞„Ç§„É≥„Éö„Éº„Ç∏ÂèñÂæó
        const loginPageResponse = await fetch('https://www.comisapolive.com/login/', {
          headers: {
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'
          }
        });
        
        const loginPageCookies = loginPageResponse.headers.get('set-cookie') || '';
        
        // „É≠„Ç∞„Ç§„É≥ÂÆüË°å
        const loginResult = await performRobustLogin(env);
        
        return new Response(JSON.stringify({
          success: true,
          analysis: {
            loginPageCookies: {
              raw: loginPageCookies,
              length: loginPageCookies.length,
              hasSessPublish: loginPageCookies.includes('SESS_PUBLISH')
            },
            loginResult: {
              success: loginResult.success,
              method: loginResult.method,
              finalCookies: {
                raw: loginResult.cookies || '',
                length: loginResult.cookies ? loginResult.cookies.length : 0,
                hasSessPublish: loginResult.cookies ? loginResult.cookies.includes('SESS_PUBLISH') : false
              }
            },
            cookieComparison: {
              beforeLogin: loginPageCookies.includes('SESS_PUBLISH') ? 'Found SESS_PUBLISH' : 'No SESS_PUBLISH',
              afterLogin: (loginResult.cookies && loginResult.cookies.includes('SESS_PUBLISH')) ? 'Found SESS_PUBLISH' : 'No SESS_PUBLISH'
            }
          }
        }), {
          headers: { ...corsHeaders, 'Content-Type': 'application/json' }
        });
      } catch (error) {
        return new Response(JSON.stringify({
          success: false,
          error: error.message
        }), {
          status: 500,
          headers: { ...corsHeaders, 'Content-Type': 'application/json' }
        });
      }
    }

    // „Éá„Éê„ÉÉ„Ç∞„Ç®„É≥„Éâ„Éù„Ç§„É≥„Éà5: KV„Çπ„Éà„É¨„Éº„Ç∏„ÅÆÂãï‰ΩúÁ¢∫Ë™ç
    if (url.pathname === '/kv-test') {
      try {
        console.log('üß™ Debug: Testing KV storage functionality...');
        
        const testKey = 'debug-test-' + Date.now();
        const testValue = { test: true, timestamp: new Date().toISOString() };
        
        // KVÊõ∏„ÅçËæº„Åø„ÉÜ„Çπ„Éà
        if (env.LIVER_DATA) {
          await env.LIVER_DATA.put(testKey, JSON.stringify(testValue));
          console.log('‚úÖ KV write test passed');
        }
        
        // KVË™≠„ÅøËæº„Åø„ÉÜ„Çπ„Éà
        const readValue = env.LIVER_DATA ? await env.LIVER_DATA.get(testKey) : null;
        const canRead = readValue !== null;
        
        // Êó¢Â≠ò„Éá„Éº„ÇøÁ¢∫Ë™ç
        const basicData = env.LIVER_DATA ? await env.LIVER_DATA.get('latest_basic_data') : null;
        const hasBasicData = basicData !== null;
        
        // „ÇØ„É™„Éº„É≥„Ç¢„ÉÉ„Éó
        if (env.LIVER_DATA) {
          await env.LIVER_DATA.delete(testKey);
        }
        
        return new Response(JSON.stringify({
          success: true,
          kvTest: {
            canWrite: true,
            canRead,
            hasBasicData,
            basicDataLength: basicData ? basicData.length : 0
          },
          environment: {
            hasLiverData: !!env.LIVER_DATA,
            hasImageHashes: !!env.IMAGE_HASHES,
            hasImages: !!env.IMAGES,
            workerAuthToken: env.WORKER_AUTH_TOKEN ? 'Set' : 'Not set',
            loginId: env.LOGIN_EMAIL ? 'Set' : 'Using fallback',
            loginPassword: env.LOGIN_PASSWORD ? 'Set' : 'Using fallback'
          }
        }), {
          headers: { ...corsHeaders, 'Content-Type': 'application/json' }
        });
      } catch (error) {
        return new Response(JSON.stringify({
          success: false,
          error: error.message,
          kvTest: {
            canWrite: false,
            canRead: false,
            error: error.message
          }
        }), {
          status: 500,
          headers: { ...corsHeaders, 'Content-Type': 'application/json' }
        });
      }
    }

    // Âü∫Êú¨„Éá„Éº„ÇøÊßãÈÄ†Á¢∫Ë™ç„Ç®„É≥„Éâ„Éù„Ç§„É≥„Éà
    if (url.pathname === '/debug-basic-data') {
      try {
        const basicDataStr = env.LIVER_DATA ? await env.LIVER_DATA.get('latest_basic_data') : null;
        if (!basicDataStr) {
          return new Response(JSON.stringify({
            success: false,
            error: 'No basic data available'
          }), {
            status: 400,
            headers: { ...corsHeaders, 'Content-Type': 'application/json' }
          });
        }
        
        const basicData = JSON.parse(basicDataStr);
        const livers = basicData.data || [];
        
        return new Response(JSON.stringify({
          success: true,
          structure: {
            dataLength: basicDataStr.length,
            rootKeys: Object.keys(basicData),
            totalLivers: livers.length,
            sampleLivers: livers.slice(0, 3).map(liver => ({
              name: liver.name,
              detailUrl: liver.detailUrl,
              allKeys: Object.keys(liver)
            }))
          }
        }), {
          headers: { ...corsHeaders, 'Content-Type': 'application/json' }
        });
      } catch (error) {
        return new Response(JSON.stringify({
          success: false,
          error: error.message
        }), {
          status: 500,
          headers: { ...corsHeaders, 'Content-Type': 'application/json' }
        });
      }
    }

    // ÂÆüÈöõ„ÅÆ„Éá„Éº„ÇøÂèñÂæó„ÉÜ„Çπ„ÉàÁî®„Ç®„É≥„Éâ„Éù„Ç§„É≥„Éà
    if (url.pathname === '/test-data-scraping') {
      try {
        console.log('üß™ Debug: Testing actual data scraping...');
        
        // Âü∫Êú¨„Éá„Éº„Çø„ÇíÂèñÂæó
        const basicDataStr = env.LIVER_DATA ? await env.LIVER_DATA.get('latest_basic_data') : null;
        if (!basicDataStr) {
          return new Response(JSON.stringify({
            success: false,
            error: 'No basic data available'
          }), {
            status: 400,
            headers: { ...corsHeaders, 'Content-Type': 'application/json' }
          });
        }
        
        const basicData = JSON.parse(basicDataStr);
        const livers = basicData.data || [];
        
        // „Éá„Éê„ÉÉ„Ç∞: Âü∫Êú¨„Éá„Éº„Çø„ÅÆÊßãÈÄ†„ÇíÁ¢∫Ë™ç
        console.log('üìä Basic data structure:', {
          totalLivers: livers.length,
          sampleLiver: livers[0],
          dataKeys: Object.keys(basicData)
        });
        
        if (livers.length === 0) {
          return new Response(JSON.stringify({
            success: false,
            error: 'No livers found in basic data',
            basicDataStructure: Object.keys(basicData)
          }), {
            headers: { ...corsHeaders, 'Content-Type': 'application/json' }
          });
        }
        
        // ÊúÄÂàù„ÅÆ3„Å§„ÅÆ„É©„Ç§„Éê„Éº„ÅßË©≥Á¥∞ÂèñÂæó„Çí„ÉÜ„Çπ„ÉàÔºàÂÆüÈöõ„ÅÆHTML„ÇÇÁ¢∫Ë™çÔºâ
        const testLivers = livers.slice(0, 3);
        const results = [];
        
        // „É≠„Ç∞„Ç§„É≥ÂÆüË°å
        const loginResult = await performRobustLogin(env);
        if (!loginResult.success) {
          return new Response(JSON.stringify({
            success: false,
            error: 'Login failed: ' + loginResult.error
          }), {
            status: 401,
            headers: { ...corsHeaders, 'Content-Type': 'application/json' }
          });
        }
        
        console.log('‚úÖ Login successful, testing data scraping...');
        
        for (const liver of testLivers) {
          try {
            // „Åæ„ÅöÁîü„ÅÆHTML„ÇíÂèñÂæó„Åó„Å¶Á¢∫Ë™ç
            const rawResponse = await fetch(liver.detailUrl, {
              headers: {
                'Cookie': loginResult.cookies,
                'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36',
                'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8'
              }
            });
            
            const rawHtml = await rawResponse.text();
            const hasLoginForm = rawHtml.includes('name=\"email\"') || rawHtml.includes('name=\"password\"');
            const pageTitle = (rawHtml.match(/<title>(.*?)<\/title>/i) || ['', 'No title'])[1];
            
            // Ë©≥Á¥∞„Çπ„ÇØ„É¨„Ç§„Éî„É≥„Ç∞ÂÆüË°å
            const result = await scrapeDetailPageWithAuth(liver.detailUrl, loginResult.cookies, 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36', env, loginResult);
            
            results.push({
              basicDataName: liver.name, // Âü∫Êú¨„Éá„Éº„Çø„Åã„ÇâÂèñÂæó„Åó„ÅüÂêçÂâç
              liverUrl: liver.detailUrl,
              rawPageInfo: {
                status: rawResponse.status,
                hasLoginForm,
                pageTitle,
                htmlLength: rawHtml.length,
                htmlPreview: rawHtml.substring(0, 300)
              },
              scrapingResult: {
                success: result.success,
                hasDetails: !!result.details,
                detailFields: result.details ? Object.keys(result.details) : [],
                detailName: result.details ? result.details.detailName : null, // Ë©≥Á¥∞„Éö„Éº„Ç∏„Åã„ÇâÂèñÂæó„Åó„ÅüÊ≠£„Åó„ÅÑÂêçÂâç
                error: result.error
              },
              nameComparison: {
                fromBasicData: liver.name,
                fromDetailPage: result.details ? result.details.detailName : null,
                fromPageTitle: pageTitle,
                mismatch: liver.name !== (result.details ? result.details.detailName : null)
              }
            });
            
            // Áü≠ÊôÇÈñìÂæÖÊ©üÔºà„É¨„Éº„ÉàÂà∂ÈôêÂØæÁ≠ñÔºâ
            await sleep(1000);
          } catch (error) {
            results.push({
              basicDataName: liver.name,
              liverUrl: liver.detailUrl,
              scrapingResult: {
                success: false,
                error: error.message
              }
            });
          }
        }
        
        const successCount = results.filter(r => r.success).length;
        const errorCount = results.filter(r => !r.success).length;
        
        return new Response(JSON.stringify({
          success: true,
          testSummary: {
            totalTested: results.length,
            successCount,
            errorCount,
            successRate: `${Math.round(successCount / results.length * 100)}%`
          },
          loginMethod: loginResult.method,
          cookieLength: loginResult.cookies.length,
          results
        }), {
          headers: { ...corsHeaders, 'Content-Type': 'application/json' }
        });
      } catch (error) {
        return new Response(JSON.stringify({
          success: false,
          error: error.message
        }), {
          status: 500,
          headers: { ...corsHeaders, 'Content-Type': 'application/json' }
        });
      }
    }

    // Â∞èË¶èÊ®°„Éê„ÉÉ„ÉÅ„ÉÜ„Çπ„ÉàÁî®„Ç®„É≥„Éâ„Éù„Ç§„É≥„Éà
    if (url.pathname === '/test-small-batch') {
      try {
        console.log('üß™ Debug: Testing small batch processing...');
        
        const basicDataStr = env.LIVER_DATA ? await env.LIVER_DATA.get('latest_basic_data') : null;
        if (!basicDataStr) {
          return new Response(JSON.stringify({
            success: false,
            error: 'No basic data available'
          }), {
            status: 400,
            headers: { ...corsHeaders, 'Content-Type': 'application/json' }
          });
        }
        
        const basicData = JSON.parse(basicDataStr);
        const livers = basicData.data || [];
        
        // ÈÄ≤Êçó„Çí„É™„Çª„ÉÉ„Éà„Åó„Å¶Â∞èË¶èÊ®°„ÉÜ„Çπ„Éà
        await env.LIVER_DATA?.delete('detail_processing_progress');
        
        // 2‰ª∂„ÅÆÂ∞èË¶èÊ®°„Éê„ÉÉ„ÉÅ„ÅßÂÆüË°å
        const result = await processSmallBatch(env, livers, 2);
        
        // ÁµêÊûú„ÇíÁ¢∫Ë™ç
        const progressStr = await env.LIVER_DATA?.get('detail_processing_progress');
        const progress = progressStr ? JSON.parse(progressStr) : { completed: [] };
        
        return new Response(JSON.stringify({
          success: true,
          batchResult: result,
          processedCount: progress.completed.length,
          processedItems: progress.completed.map(item => ({
            name: item.name,
            success: item.hasDetails,
            error: item.detailError,
            detailFields: item.details ? Object.keys(item.details) : []
          }))
        }), {
          headers: { ...corsHeaders, 'Content-Type': 'application/json' }
        });
      } catch (error) {
        return new Response(JSON.stringify({
          success: false,
          error: error.message
        }), {
          status: 500,
          headers: { ...corsHeaders, 'Content-Type': 'application/json' }
        });
      }
    }

    // „Éê„ÉÉ„ÉÅË©≥Á¥∞ÂèñÂæóÈñãÂßã„Ç®„É≥„Éâ„Éù„Ç§„É≥„ÉàÔºàÊóß„Ç∑„Çπ„ÉÜ„É†Ôºâ
    if (url.pathname === '/start-batch') {
      try {
        const basicDataStr = env.LIVER_DATA ? await env.LIVER_DATA.get('latest_basic_data') : null;
        if (!basicDataStr) {
          return new Response(JSON.stringify({
            success: false,
            error: 'No basic data available'
          }), {
            status: 400,
            headers: { ...corsHeaders, 'Content-Type': 'application/json' }
          });
        }
        
        const basicData = JSON.parse(basicDataStr);
        const livers = basicData.data || [];
        const requestedBatchSize = parseInt(url.searchParams.get('batch')) || 15;
        // SubrequestÂà∂ÈôêÂØæÁ≠ñ: „Éê„ÉÉ„ÉÅ„Çµ„Ç§„Ç∫„ÇíÂà∂Èôê
        const safeBatchSize = Math.min(requestedBatchSize, 1);
        console.log(`‚ö†Ô∏è Limiting batch size from ${requestedBatchSize} to ${safeBatchSize} for subrequest limits`);
        
        // Ë©≥Á¥∞ÊÉÖÂ†±„Éê„ÉÉ„ÉÅÂá¶ÁêÜ„ÇíÂÆüË°å
        const result = await processDetailsBatch(env, livers, safeBatchSize);
        
        return new Response(JSON.stringify({
          success: true,
          message: `Processed ${result.processed} livers with ${result.errors} errors`,
          total: result.total,
          processed: result.processed,
          errors: result.errors
        }), {
          headers: { ...corsHeaders, 'Content-Type': 'application/json' }
        });
      } catch (error) {
        return new Response(JSON.stringify({
          success: false,
          error: error.message
        }), {
          status: 500,
          headers: { ...corsHeaders, 'Content-Type': 'application/json' }
        });
      }
    }
    
    // detail-batch „Ç®„É≥„Éâ„Éù„Ç§„É≥„Éà
    if (url.pathname === '/detail-batch') {
      const batchSize = parseInt(url.searchParams.get('batch')) || 15;
      
      try {
        const basicDataStr = env.LIVER_DATA ? await env.LIVER_DATA.get('latest_basic_data') : null;
        if (!basicDataStr) {
          return new Response(JSON.stringify({
            success: false,
            error: 'No basic data available'
          }), {
            status: 400,
            headers: { ...corsHeaders, 'Content-Type': 'application/json' }
          });
        }
        
        const basicData = JSON.parse(basicDataStr);
        const livers = basicData.data || [];
        
        // SubrequestÂà∂ÈôêÂØæÁ≠ñ
        const safeBatchSize = Math.min(batchSize, 1);
        const result = await processDetailsBatch(env, livers, safeBatchSize);
        
        return new Response(JSON.stringify({
          success: true,
          processed: result.processed,
          errors: result.errors,
          total: livers.length
        }), {
          headers: { ...corsHeaders, 'Content-Type': 'application/json' }
        });
      } catch (error) {
        return new Response(JSON.stringify({
          success: false,
          error: error.message
        }), {
          status: 500,
          headers: { ...corsHeaders, 'Content-Type': 'application/json' }
        });
      }
    }
    
    // Ë™çË®º„ÉÜ„Çπ„Éà„Ç®„É≥„Éâ„Éù„Ç§„É≥„Éà
    if (url.pathname === '/test-login') {
      try {
        console.log('üîê Testing login functionality...');
        const loginResult = await performRobustLogin(env);
        
        return new Response(JSON.stringify({
          success: loginResult.success,
          message: loginResult.success ? 'Login successful' : 'Login failed',
          error: loginResult.error || null,
          hasCredentials: {
            email: !!env.LOGIN_EMAIL,
            password: !!env.LOGIN_PASSWORD
          }
        }), {
          headers: { ...corsHeaders, 'Content-Type': 'application/json' }
        });
      } catch (error) {
        return new Response(JSON.stringify({
          success: false,
          error: error.message,
          hasCredentials: {
            email: !!env.LOGIN_EMAIL,
            password: !!env.LOGIN_PASSWORD
          }
        }), {
          status: 500,
          headers: { ...corsHeaders, 'Content-Type': 'application/json' }
        });
      }
    }

    // „Éá„Éº„ÇøÁ¢∫Ë™ç„Ç®„É≥„Éâ„Éù„Ç§„É≥„Éà
    if (url.pathname === '/check-data') {
      try {
        // Âü∫Êú¨„Éá„Éº„Çø„ÇíÂèñÂæó
        const basicDataStr = await env.LIVER_DATA?.get('latest_basic_data');
        const detailedDataStr = await env.LIVER_DATA?.get('latest_detailed_data');
        const progressStr = await env.LIVER_DATA?.get('detail_processing_progress');
        
        const basicData = basicDataStr ? JSON.parse(basicDataStr) : null;
        const detailedData = detailedDataStr ? JSON.parse(detailedDataStr) : null;
        const progress = progressStr ? JSON.parse(progressStr) : null;
        
        return new Response(JSON.stringify({
          success: true,
          data: {
            basicData: {
              exists: !!basicData,
              count: basicData?.data?.length || 0,
              timestamp: basicData?.timestamp,
              lastUpdate: basicData?.lastUpdate,
              sample: basicData?.data?.slice(0, 3) || [] // ÊúÄÂàù„ÅÆ3‰ª∂„ÅÆ„Çµ„É≥„Éó„É´
            },
            detailedData: {
              exists: !!detailedData,
              count: detailedData?.data?.length || 0,
              timestamp: detailedData?.timestamp,
              lastUpdate: detailedData?.lastUpdate,
              processed: detailedData?.processed || 0,
              errors: detailedData?.errors || 0
            },
            progress: {
              exists: !!progress,
              completed: progress?.completed?.length || 0,
              lastIndex: progress?.lastIndex || 0
            },
            environment: {
              hasLoginEmail: !!env.LOGIN_EMAIL,
              hasLoginPassword: !!env.LOGIN_PASSWORD,
              hasWorkerAuthToken: !!env.WORKER_AUTH_TOKEN,
              imageWorkerUrl: env.IMAGE_WORKER_URL || 'not set'
            }
          }
        }), {
          headers: { ...corsHeaders, 'Content-Type': 'application/json' }
        });
      } catch (error) {
        return new Response(JSON.stringify({
          success: false,
          error: error.message
        }), {
          status: 500,
          headers: { ...corsHeaders, 'Content-Type': 'application/json' }
        });
      }
    }

    // „Ç®„É©„ÉºË©≥Á¥∞Á¢∫Ë™ç„Ç®„É≥„Éâ„Éù„Ç§„É≥„Éà
    if (url.pathname === '/check-errors') {
      try {
        const progressStr = await env.LIVER_DATA?.get('detail_processing_progress');
        const progress = progressStr ? JSON.parse(progressStr) : null;
        
        if (!progress || !progress.completed) {
          return new Response(JSON.stringify({
            success: false,
            error: 'No processing data found'
          }), {
            status: 404,
            headers: { ...corsHeaders, 'Content-Type': 'application/json' }
          });
        }
        
        const erroredItems = progress.completed.filter(item => item.detailError);
        const successItems = progress.completed.filter(item => item.hasDetails);
        
        return new Response(JSON.stringify({
          success: true,
          summary: {
            total: progress.completed.length,
            errors: erroredItems.length,
            success: successItems.length,
            errorRate: `${Math.round(erroredItems.length / progress.completed.length * 100)}%`
          },
          errorDetails: erroredItems.map(item => ({
            name: item.name,
            detailUrl: item.detailUrl,
            error: item.detailError
          })),
          sampleSuccess: successItems.slice(0, 3)
        }), {
          headers: { ...corsHeaders, 'Content-Type': 'application/json' }
        });
      } catch (error) {
        return new Response(JSON.stringify({
          success: false,
          error: error.message
        }), {
          status: 500,
          headers: { ...corsHeaders, 'Content-Type': 'application/json' }
        });
      }
    }

    // ÈÄ≤Êçó„É™„Çª„ÉÉ„Éà„Ç®„É≥„Éâ„Éù„Ç§„É≥„Éà
    if (url.pathname === '/reset-progress') {
      try {
        await env.LIVER_DATA?.delete('detail_processing_progress');
        await env.LIVER_DATA?.delete('login_session');
        
        return new Response(JSON.stringify({
          success: true,
          message: 'Progress and session data cleared. Next run will start fresh.'
        }), {
          headers: { ...corsHeaders, 'Content-Type': 'application/json' }
        });
      } catch (error) {
        return new Response(JSON.stringify({
          success: false,
          error: error.message
        }), {
          status: 500,
          headers: { ...corsHeaders, 'Content-Type': 'application/json' }
        });
      }
    }

    // ÈÄ≤ÊçóÁ¢∫Ë™ç„Ç®„É≥„Éâ„Éù„Ç§„É≥„Éà
    if (url.pathname === '/progress') {
      try {
        const status = await env.LIVER_DATA.get('worker_status_details');
        return new Response(JSON.stringify({
          success: true,
          status: status ? JSON.parse(status) : null
        }), {
          headers: { ...corsHeaders, 'Content-Type': 'application/json' }
        });
      } catch (error) {
        return new Response(JSON.stringify({
          success: false,
          error: error.message
        }), {
          status: 500,
          headers: { ...corsHeaders, 'Content-Type': 'application/json' }
        });
      }
    }
    
    return new Response('Not Found', { status: 404 });
  }
};

// Ë©≥Á¥∞ÊÉÖÂ†±„Çí„Éê„ÉÉ„ÉÅÂá¶ÁêÜ„ÅßÂèñÂæó
async function processDetailsBatch(env, livers, batchSize = 1) {
  console.log(`üîç Starting batch detail processing: ${livers.length} livers, batch size: ${batchSize}`);
  
  let processed = 0;
  let errors = 0;
  const detailedLivers = [];
  
  // „Çª„ÉÉ„Ç∑„Éß„É≥ÁÆ°ÁêÜ: Êó¢Â≠ò„ÅÆ„Çª„ÉÉ„Ç∑„Éß„É≥„Çí„ÉÅ„Çß„ÉÉ„ÇØ
  let loginResult = await getStoredSession(env);
  if (!loginResult || !loginResult.success) {
    // Êñ∞„Åó„ÅÑ„É≠„Ç∞„Ç§„É≥ÂÆüË°å
    loginResult = await performRobustLogin(env);
    if (!loginResult.success) {
      throw new Error(`Login failed: ${loginResult.error}`);
    }
    // „Çª„ÉÉ„Ç∑„Éß„É≥„Çí‰øùÂ≠ò
    await storeSession(env, loginResult);
  } else {
    console.log('üîÑ Reusing stored session');
  }
  
  await updateWorkerStatus(env, 'details', 'in_progress', {
    total: livers.length,
    processed: 0,
    errors: 0
  });
  
  // „Éê„ÉÉ„ÉÅ„Åî„Å®„Å´Âá¶ÁêÜ
  for (let i = 0; i < livers.length; i += batchSize) {
    const batch = livers.slice(i, i + batchSize);
    console.log(`üì¶ Processing batch ${Math.floor(i / batchSize) + 1}/${Math.ceil(livers.length / batchSize)}: ${batch.length} livers`);
    
    // „Éê„ÉÉ„ÉÅÂÜÖ„ÅßÈÄêÊ¨°Âá¶ÁêÜÔºà‰∏¶ÂàóÂá¶ÁêÜ„ÇíÂÅúÊ≠¢„Åó„Å¶SubrequestÂà∂Èôê„ÇíÂõûÈÅøÔºâ
    for (const liver of batch) {
      try {
        const detailInfo = await scrapeDetailPageWithAuth(liver.detailUrl, loginResult.cookies, loginResult.userAgent || 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36', env, loginResult);
        
        if (detailInfo) {
          const detailedLiver = {
            ...liver,
            ...detailInfo,
            hasDetails: true,
            detailScrapedAt: new Date().toISOString()
          };
          detailedLivers.push(detailedLiver);
          processed++;
          
          console.log(`‚úÖ ${liver.name} - Details collected`);
        } else {
          console.log(`‚ö†Ô∏è ${liver.name} - No details found`);
          detailedLivers.push({
            ...liver,
            hasDetails: false
          });
        }
        
        // ÂÄãÂà•„É™„ÇØ„Ç®„Çπ„ÉàÈñì„ÅÆÂæÖÊ©üÊôÇÈñì„ÇíÁü≠Á∏ÆÔºà„Çª„ÉÉ„Ç∑„Éß„É≥Á∂≠ÊåÅ„ÅÆ„Åü„ÇÅÔºâ
        await sleep(500);
        
      } catch (error) {
        console.error(`‚ùå ${liver.name} - Detail scraping failed:`, error.message);
        
        // Ë™çË®º„Ç®„É©„Éº„ÅÆÂ†¥Âêà„ÅØÂÜç„É≠„Ç∞„Ç§„É≥Ë©¶Ë°å
        if (error.message.includes('Ë™çË®ºÂ§±Êïó') || error.message.includes('„É≠„Ç∞„Ç§„É≥„Éö„Éº„Ç∏')) {
          console.log('üîÑ Authentication failed, attempting re-login...');
          try {
            loginResult = await performRobustLogin(env);
            if (loginResult.success) {
              await storeSession(env, loginResult);
              console.log('‚úÖ Re-login successful, continuing...');
              // ÂÜç„É≠„Ç∞„Ç§„É≥ÊàêÂäüÊôÇ„ÅØ„Çπ„Ç≠„ÉÉ„ÉóÔºàÊ¨°„ÅÆ„Éê„ÉÉ„ÉÅ„ÅßÂÜçË©¶Ë°åÔºâ
            }
          } catch (reloginError) {
            console.error('‚ùå Re-login failed:', reloginError.message);
          }
        }
        
        errors++;
        // „Ç®„É©„Éº„Åß„ÇÇÂü∫Êú¨ÊÉÖÂ†±„ÅØ‰øùÊåÅ
        detailedLivers.push({
          ...liver,
          hasDetails: false,
          detailError: error.message
        });
      }
    }
    
    // ÈÄ≤ÊçóÊõ¥Êñ∞
    await updateWorkerStatus(env, 'details', 'in_progress', {
      total: livers.length,
      processed: processed,
      errors: errors,
      currentBatch: Math.floor(i / batchSize) + 1,
      totalBatches: Math.ceil(livers.length / batchSize)
    });
    
    // „Éê„ÉÉ„ÉÅÈñì„ÅÆÂæÖÊ©üÊôÇÈñì„ÇíÂª∂Èï∑ÔºàSubrequestÂà∂ÈôêÂØæÁ≠ñÔºâ
    if (i + batchSize < livers.length) {
      console.log('‚è±Ô∏è Waiting between batches...');
      await sleep(10000); // 5Áßí„Åã„Çâ10Áßí„Å´Âª∂Èï∑
    }
  }
  
  // Ë©≥Á¥∞„Éá„Éº„Çø„Çí‰øùÂ≠ò
  if (env.LIVER_DATA && detailedLivers.length > 0) {
    await env.LIVER_DATA.put('latest_detailed_data', JSON.stringify({
      timestamp: Date.now(),
      total: detailedLivers.length,
      data: detailedLivers,
      lastUpdate: new Date().toISOString(),
      processed: processed,
      errors: errors
    }));
    console.log(`üíæ Saved detailed data: ${detailedLivers.length} livers`);
  }
  
  console.log(`‚úÖ Batch processing completed: ${processed} successful, ${errors} errors`);
  return { processed, errors, total: livers.length };
}

// Ë©≥Á¥∞„Éö„Éº„Ç∏„Çí„Çπ„ÇØ„É¨„Ç§„Éî„É≥„Ç∞Ôºà„Éê„ÉÉ„ÇØ„Ç¢„ÉÉ„Éó„Éï„Ç°„Ç§„É´„Åã„ÇâÂæ©ÂÖÉÔºâ
async function scrapeDetailPageWithAuth(detailUrl, cookies, userAgent, env, loginResult = null) {
  try {
    console.log(`üîç Accessing detail page: ${detailUrl}`);
    console.log(`üç™ Using cookies (length: ${cookies.length})`);
    
    const response = await fetch(detailUrl, {
      headers: {
        'Cookie': cookies,
        'User-Agent': userAgent || 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36',
        'Referer': 'https://www.comisapolive.com/',
        'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8',
        'Accept-Language': 'ja,en-US;q=0.9,en;q=0.8',
        'Accept-Encoding': 'gzip, deflate, br',
        'Connection': 'keep-alive',
        'Upgrade-Insecure-Requests': '1'
      }
    });
    
    console.log(`üìÑ Detail response: ${response.status} -> ${response.url}`);
    
    if (!response.ok) {
      console.error(`Failed to fetch detail page: ${response.status}`);
      return { 
        success: false,
        error: `HTTP ${response.status}` 
      };
    }
    
    const html = await response.text();
    
    // „É≠„Ç∞„Ç§„É≥„ÅåÂøÖË¶Å„Åã„Çà„ÇäÂé≥ÂØÜ„Å´„ÉÅ„Çß„ÉÉ„ÇØ
    const requiresLogin = (
      response.url.includes('login') ||
      html.includes('„Éë„Çπ„ÉØ„Éº„Éâ') ||
      html.includes('„É≠„Ç∞„Ç§„É≥„ÅåÂøÖË¶Å') ||
      html.includes('Ë™çË®º„ÅåÂøÖË¶Å') ||
      (html.includes('„É≠„Ç∞„Ç§„É≥') && html.length < 5000) || // Â∞è„Åï„Å™„Éö„Éº„Ç∏„ÅØ„É≠„Ç∞„Ç§„É≥„Éö„Éº„Ç∏„ÅÆÂèØËÉΩÊÄß
      html.includes('„É≠„Ç∞„Ç§„É≥„Éö„Éº„Ç∏')
    );

    if (requiresLogin) {
      console.log('‚ö†Ô∏è Authentication required for this detail page');
      return {
        success: false,
        requiresLogin: true
      };
    }
    
    const detailInfo = {};
    
    // ÂÖ®„Å¶„ÅÆË©≥Á¥∞ÊÉÖÂ†±„ÇíÊäΩÂá∫
    try {
      // „Ç´„ÉÜ„Ç¥„É™ÔºöliverProf_tag
      const categories = extractTextFromClass(html, 'liverProf_tag');
      if (categories.length > 0) detailInfo.categories = categories;
      
      // „É©„Ç§„Éê„ÉºÂêçÔºöliverProf_name
      const detailName = extractTextFromClass(html, 'liverProf_name');
      if (detailName.length > 0) detailInfo.detailName = detailName[0];
      
      // „Éï„Ç©„É≠„ÉØ„ÉºÊï∞ÔºöliverProf_follwer
      const detailFollowers = extractTextFromClass(html, 'liverProf_follwer');
      if (detailFollowers.length > 0) detailInfo.detailFollowers = detailFollowers[0];
      
      // „Éó„É≠„Éï„Ç£„Éº„É´ÁîªÂÉèÔºöliverImage_views
      const profileImages = await extractImagesFromClass(html, 'liverImage_views', env);
      if (profileImages.length > 0) detailInfo.profileImages = profileImages;
      
      // „Ç≥„É©„ÉúÈÖç‰ø°Âà§ÂÆöÔºöliverProf_collaboOK„ÇØ„É©„Çπ„ÅÆÊúâÁÑ°„ÅßÂà§ÂÆö
      const collaboOKElements = extractTextFromClass(html, 'liverProf_collaboOK');
      if (collaboOKElements.length > 0) {
        // OK„ÇØ„É©„Çπ„ÅåÂ≠òÂú®„Åô„ÇãÂ†¥Âêà
        detailInfo.collaborationStatus = 'OK';
        detailInfo.collaborationComment = collaboOKElements[0]; // „Ç≥„É°„É≥„ÉàÂÜÖÂÆπ„ÇÇ‰øùÂ≠ò
      } else {
        // OK„ÇØ„É©„Çπ„ÅåÂ≠òÂú®„Åó„Å™„ÅÑÂ†¥Âêà„ÅØNGÂà§ÂÆö
        detailInfo.collaborationStatus = 'NG';
        // NG„ÅÆ„Ç≥„É°„É≥„Éà„Åå„ÅÇ„Çå„Å∞ÂèñÂæó
        const collaboNGElements = extractTextFromClass(html, 'liverProf_collaboNG');
        if (collaboNGElements.length > 0) {
          detailInfo.collaborationComment = collaboNGElements[0];
        } else {
          detailInfo.collaborationComment = '„Ç≥„É©„ÉúÈÖç‰ø°„Å´Èñ¢„Åô„ÇãË®òËºâ„Å™„Åó';
        }
      }
      
      // ÂêÑÂ™í‰Ωì„É™„É≥„ÇØÔºöliverProf_info
      const mediaLinks = extractLinksFromClass(html, 'liverProf_info');
      if (mediaLinks.length > 0) detailInfo.mediaLinks = mediaLinks;
      
      // „Éó„É≠„Éï„Ç£„Éº„É´ÊÉÖÂ†±ÔºàÊÄßÂà•„ÄÅÈÖç‰ø°Ê≠¥„ÄÅÁîüÂπ¥ÊúàÊó•ÔºâÔºöliverProf_prof
      const profileTexts = extractTextFromClass(html, 'liverProf_prof');
      if (profileTexts.length > 0) {
        detailInfo.profileInfo = parseProfileInfo(profileTexts);
        detailInfo.rawProfileTexts = profileTexts; // „Éá„Éê„ÉÉ„Ç∞Áî®
      }
      
      // „Ç§„Éô„É≥„ÉàÊÉÖÂ†±ÔºöliverEvent_scheduleTxt
      const eventInfo = extractTextFromClass(html, 'liverEvent_scheduleTxt');
      if (eventInfo.length > 0) detailInfo.eventInfo = eventInfo;
      
      // „É©„Ç§„Éê„Éº„Ç≥„É°„É≥„ÉàÔºöliverComment_body
      const comments = extractTextFromClass(html, 'liverComment_body');
      if (comments.length > 0) detailInfo.comments = comments;
      
      // ÈÖç‰ø°Â™í‰Ωì„ÉªURL„ÉªÁôªÈå≤ËÄÖÊï∞Ôºöschedules_name, schedules_id, schedules_follwer
      const scheduleInfo = extractScheduleInfo(html);
      if (scheduleInfo.length > 0) detailInfo.schedules = scheduleInfo;
      
      // üîó schedules_id„ÇØ„É©„ÇπÂ∞ÇÁî®URLÊäΩÂá∫ÔºàË©≥Á¥∞„Å™ÈÖç‰ø°ÂÖàÊÉÖÂ†±Ôºâ
      const scheduleUrls = extractSchedulesIdUrls(html);
      if (scheduleUrls.length > 0) {
        detailInfo.streamingUrls = scheduleUrls;
        console.log(`üì∫ ${scheduleUrls.length} streaming URLs extracted: ${scheduleUrls.map(u => u.type).join(', ')}`);
      }
      
      // ÊÄßÂà•„Éá„Éº„Çø„ÅÆÁâπÂà•Ê§úÁ¥¢
      const genderSearch = findGenderData(html);
      if (genderSearch && genderSearch.gender) {
        detailInfo.genderFound = genderSearch;
        if (!detailInfo.profileInfo) detailInfo.profileInfo = {};
        if (!detailInfo.profileInfo.gender) {
          detailInfo.profileInfo.gender = genderSearch.gender;
        }
      }
      
    } catch (extractError) {
      console.error('Detail extraction error:', extractError);
      detailInfo.extractionError = extractError.message;
    }
    
    return {
      success: true,
      details: detailInfo,
      htmlLength: html.length
    };
    
  } catch (error) {
    console.error(`Error scraping detail page ${detailUrl}:`, error);
    return { 
      success: false,
      error: error.message 
    };
  }
}

// Worker3ÔºàÁîªÂÉèÂèñÂæóÔºâ„Çí„Éà„É™„Ç¨„Éº
async function triggerImageWorker(env) {
  try {
    console.log('üîÑ Triggering image worker...');
    
    const imageWorkerUrl = env.IMAGE_WORKER_URL;
    if (!imageWorkerUrl) {
      console.log('‚ö†Ô∏è IMAGE_WORKER_URL not configured, skipping image trigger');
      return;
    }
    
    const response = await fetch(`${imageWorkerUrl}/start-batch`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${env.WORKER_AUTH_TOKEN || 'default-token'}`
      },
      body: JSON.stringify({
        trigger: 'detail-worker',
        timestamp: Date.now()
      })
    });
    
    if (!response.ok) {
      throw new Error(`Failed to trigger image worker: ${response.status}`);
    }
    
    console.log('‚úÖ Image worker triggered successfully');
    
  } catch (error) {
    console.error('‚ùå Failed to trigger image worker:', error.message);
    // „Ç®„É©„Éº„Åß„ÇÇÂá¶ÁêÜ„ÇíÁ∂ôÁ∂ö
  }
}

// === „É¶„Éº„ÉÜ„Ç£„É™„ÉÜ„Ç£Èñ¢Êï∞ ===

async function updateWorkerStatus(env, workerName, status, data = {}) {
  if (!env.LIVER_DATA) return;
  
  try {
    await env.LIVER_DATA.put(`worker_status_${workerName}`, JSON.stringify({
      status: status,
      timestamp: Date.now(),
      lastUpdate: new Date().toISOString(),
      ...data
    }));
  } catch (error) {
    console.error(`Failed to update status for ${workerName}:`, error.message);
  }
}

async function performRobustLogin(env) {
  try {
    console.log('üîê Starting login process...');
    
    // 1. „É≠„Ç∞„Ç§„É≥„Éö„Éº„Ç∏„ÇíÂèñÂæó
    const loginPageResponse = await fetch('https://www.comisapolive.com/login/', {
      headers: {
        'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
        'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8',
        'Accept-Language': 'ja,en-US;q=0.9,en;q=0.8'
      }
    });
    
    if (!loginPageResponse.ok) {
      return { success: false, error: `Login page failed: ${loginPageResponse.status}` };
    }
    
    const loginPageHtml = await loginPageResponse.text();
    const loginPageCookies = loginPageResponse.headers.get('set-cookie') || '';
    
    // 2. „Éï„Ç©„Éº„É†ÊÉÖÂ†±„ÇíÊäΩÂá∫
    const csrfToken = extractCSRFToken(loginPageHtml);
    const hiddenFields = extractHiddenFields(loginPageHtml);
    const actionUrl = extractFormAction(loginPageHtml) || 'https://www.comisapolive.com/login/';
    
    console.log('üìù Form analysis complete:', {
      csrf: !!csrfToken,
      hidden: Object.keys(hiddenFields).length,
      action: actionUrl.includes('login')
    });
    
    // 3. „É≠„Ç∞„Ç§„É≥„Éá„Éº„Çø„ÇíÊ∫ñÂÇô
    const loginData = new URLSearchParams();
    
    // Áí∞Â¢ÉÂ§âÊï∞„Åã„ÇâË™çË®ºÊÉÖÂ†±„ÇíÂèñÂæóÔºàfallback‰ªò„ÅçÔºâ
    const email = env.LOGIN_EMAIL || 'comisapolive@gmail.com';
    const password = env.LOGIN_PASSWORD || 'cord3cord3';
    
    // Ë§áÊï∞„ÅÆ„Éï„Ç£„Éº„É´„ÉâÂêç„Éë„Çø„Éº„É≥„ÇíË©¶Ë°å
    const emailFields = ['email', 'username', 'login_id', 'user_email', 'mail'];
    const passwordFields = ['password', 'passwd', 'pass', 'login_password'];
    
    emailFields.forEach(field => {
      loginData.append(field, email);
    });
    
    passwordFields.forEach(field => {
      loginData.append(field, password);
    });
    
    // CSRFÂØæÂøú
    if (csrfToken) {
      const csrfFields = ['csrf_token', '_token', 'authenticity_token', 'csrfmiddlewaretoken'];
      csrfFields.forEach(field => {
        loginData.append(field, csrfToken);
      });
    }
    
    // hidden „Éï„Ç£„Éº„É´„ÉâËøΩÂä†
    Object.entries(hiddenFields).forEach(([name, value]) => {
      loginData.append(name, value);
    });
    
    // 4. „É≠„Ç∞„Ç§„É≥ÂÆüË°å
    const loginResponse = await fetch(actionUrl, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/x-www-form-urlencoded',
        'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36',
        'Referer': 'https://www.comisapolive.com/login/',
        'Origin': 'https://www.comisapolive.com',
        'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8',
        'Cookie': loginPageCookies
      },
      body: loginData.toString(),
      redirect: 'manual'
    });
    
    const loginResponseCookies = loginResponse.headers.get('set-cookie') || '';
    const allCookies = combineCookies(loginPageCookies, loginResponseCookies);

    // „Éá„Éê„ÉÉ„Ç∞ÊÉÖÂ†±„ÇíËøΩÂä†
    console.log('üîç Login response analysis:', {
      status: loginResponse.status,
      url: loginResponse.url,
      hasSetCookie: !!loginResponseCookies,
      cookieLength: loginResponseCookies.length,
      totalCookieLength: allCookies.length
    });

    // 5. ÊàêÂäüÂà§ÂÆö„ÅÆÂ§âÊï∞ÂàùÊúüÂåñ
    let success = false;
    let method = '';
    
    // „É™„ÉÄ„Ç§„É¨„ÇØ„ÉàÂà§ÂÆö
    if (loginResponse.status >= 300 && loginResponse.status < 400) {
      const location = loginResponse.headers.get('location');
      console.log('üìç Redirect detected:', { 
        location, 
        hasLogin: location?.includes('login'),
        hasError: location?.includes('error')
      });
      
      if (location && !location.includes('login') && !location.includes('error')) {
        success = true;
        method = 'redirect';
      }
    }
    
    // „É¨„Çπ„Éù„É≥„ÇπÂÜÖÂÆπÂà§ÂÆö
    if (!success) {
      const loginResponseText = await loginResponse.text();
      console.log('üìÑ Response preview (first 300 chars):', loginResponseText.substring(0, 300));
      console.log('üìä Response length:', loginResponseText.length);
      
      const successPatterns = ['dashboard', '„Éû„Ç§„Éö„Éº„Ç∏', '„É≠„Ç∞„Ç¢„Ç¶„Éà', 'menu', 'profile', 'liver', 'Ë®≠ÂÆö', '„Éõ„Éº„É†', '„Ç¢„Ç´„Ç¶„É≥„Éà'];
      const failurePatterns = ['„É≠„Ç∞„Ç§„É≥„Å´Â§±Êïó', '„Éë„Çπ„ÉØ„Éº„Éâ„ÅåÈñìÈÅï', 'Ë™çË®º„Å´Â§±Êïó', 'error', '„Ç®„É©„Éº', '„É≠„Ç∞„Ç§„É≥ÁîªÈù¢', '„Éë„Çπ„ÉØ„Éº„Éâ', '„É°„Éº„É´„Ç¢„Éâ„É¨„Çπ'];
      
      const hasSuccess = successPatterns.some(pattern => 
        loginResponseText.toLowerCase().includes(pattern.toLowerCase())
      );
      const hasFailure = failurePatterns.some(pattern => 
        loginResponseText.toLowerCase().includes(pattern.toLowerCase())
      );
      
      console.log('üéØ Pattern matching:', { 
        hasSuccess, 
        hasFailure,
        foundSuccess: successPatterns.filter(p => loginResponseText.toLowerCase().includes(p.toLowerCase())),
        foundFailure: failurePatterns.filter(p => loginResponseText.toLowerCase().includes(p.toLowerCase()))
      });
      
      if (hasSuccess && !hasFailure) {
        success = true;
        method = 'content';
      }
    }
    
    // CookieÂà§ÂÆö
    if (!success && allCookies.length > loginPageCookies.length) {
      const sessionPatterns = ['session', 'auth', 'login', 'token', 'user'];
      const hasSessionCookie = sessionPatterns.some(pattern =>
        allCookies.toLowerCase().includes(pattern)
      );
      
      if (hasSessionCookie) {
        success = true;
        method = 'cookie';
      }
    }

    // „Çà„ÇäÁ∑©„ÅÑÊàêÂäüÂà§ÂÆöÔºàÊúÄÂæå„ÅÆÊâãÊÆµÔºâ
    if (!success && loginResponse.status === 200) {
      const loginResponseText = await loginResponse.text();
      // „É≠„Ç∞„Ç§„É≥„Éö„Éº„Ç∏„ÅÆÁâπÂæ¥„Åå„Å™„ÅÑÂ†¥Âêà„ÅØÊàêÂäü„Å®„Åø„Å™„Åô
      if (!loginResponseText.includes('„Éë„Çπ„ÉØ„Éº„Éâ') && 
        !loginResponseText.includes('„É≠„Ç∞„Ç§„É≥') && 
        loginResponseText.length > 1000) {
        success = true;
        method = 'fallback';
        console.log('üé≤ Using fallback success detection - no login indicators found');
      }
    }
    
    console.log(`üîê Login result: ${success ? '‚úÖ SUCCESS' : '‚ùå FAILED'} (${method})`);
    
    return {
      success,
      cookies: allCookies,
      method,
      error: success ? null : 'Login failed - no success indicators found'
    };
    
  } catch (error) {
    console.error('Login error:', error);
    return {
      success: false,
      error: error.message
    };
  }
}


function combineCookies(cookies1, cookies2) {
  console.log('üç™ Raw cookies1:', cookies1);
  console.log('üç™ Raw cookies2:', cookies2);
  
  let finalCookies = '';
  
  if (cookies2 && cookies2.includes('SESS_PUBLISH')) {
    // cookies2„Åã„ÇâÊúÄÊñ∞„ÅÆSESS_PUBLISH„ÇíÊäΩÂá∫
    const sessMatches = cookies2.match(/SESS_PUBLISH=([^;,]+)/g);
    if (sessMatches && sessMatches.length > 0) {
      // ÊúÄÂæå„ÅÆ„Éû„ÉÉ„ÉÅ„Çí‰ΩøÁî®
      finalCookies = sessMatches[sessMatches.length - 1];
      console.log('üç™ Using latest SESS_PUBLISH:', finalCookies);
    }
  } else if (cookies1 && cookies1.includes('SESS_PUBLISH')) {
    // cookies1„Åã„ÇâÊäΩÂá∫
    const sessMatch = cookies1.match(/SESS_PUBLISH=([^;,]+)/);
    if (sessMatch) {
      finalCookies = `SESS_PUBLISH=${sessMatch[1]}`;
      console.log('üç™ Using cookies1 SESS_PUBLISH:', finalCookies);
    }
  }
  
  return finalCookies;
}

// Ë£úÂä©Èñ¢Êï∞Ôºö„É™„É≥„ÇØÊäΩÂá∫
function extractLinksFromClass(html, className) {
  const results = [];
  const pattern = new RegExp(`<[^>]*class="[^"]*${className}[^"]*"[^>]*>([\\s\\S]*?)<\/[^>]+>`, 'g');
  let match;
  
  while ((match = pattern.exec(html)) !== null) {
    const linkPattern = /<a[^>]*href="([^"]*)"[^>]*>([^<]*)<\/a>/g;
    let linkMatch;
    
    while ((linkMatch = linkPattern.exec(match[1])) !== null) {
      results.push({
        url: linkMatch[1],
        text: linkMatch[2].trim()
      });
    }
  }
  
  return results;
}

// Ë£úÂä©Èñ¢Êï∞ÔºöÁîªÂÉèÊäΩÂá∫ÔºàÁ∞°ÊòìÁâàÔºâ
async function extractImagesFromClass(html, className, env) {
  const results = [];
  const pattern = new RegExp(`<[^>]*class="[^"]*${className}[^"]*"[^>]*>([\\s\\S]*?)<\/[^>]+>`, 'g');
  let match;
  let imageIndex = 0;
  
  while ((match = pattern.exec(html)) !== null) {
    const imgPattern = /<img[^>]*src="([^"]*)"[^>]*>/g;
    let imgMatch;
    
    while ((imgMatch = imgPattern.exec(match[1])) !== null) {
      const imageUrl = imgMatch[1];
      const fullImageUrl = imageUrl.startsWith('/') 
        ? `https://www.comisapolive.com${imageUrl}` 
        : imageUrl;
      
      results.push({
        url: fullImageUrl,
        originalUrl: fullImageUrl
      });
      
      imageIndex++;
    }
  }
  
  return results;
}

// Ë£úÂä©Èñ¢Êï∞Ôºö„Çπ„Ç±„Ç∏„É•„Éº„É´ÊÉÖÂ†±ÊäΩÂá∫
function extractScheduleInfo(html) {
  const schedules = [];
  
  // schedules_name, schedules_id, schedules_follwer „ÇíÂêåÊôÇ„Å´ÊäΩÂá∫
  const schedulePattern = /<[^>]*class="[^"]*schedules_name[^"]*"[^>]*>([^<]*)<\/[^>]*>[\s\S]*?<[^>]*class="[^"]*schedules_id[^"]*"[^>]*href="([^"]*)"[^>]*>[\s\S]*?<[^>]*class="[^"]*schedules_follwer[^"]*"[^>]*>([^<]*)<\/[^>]*>/g;
  let match;
  
  while ((match = schedulePattern.exec(html)) !== null) {
    schedules.push({
      name: match[1].trim(),
      url: match[2],
      followers: match[3].trim()
    });
  }
  
  // ÂÄãÂà•„Å´ÊäΩÂá∫„Åô„ÇãÊñπÊ≥ï„ÇÇ‰ΩµÁî®
  if (schedules.length === 0) {
    const names = extractTextFromClass(html, 'schedules_name');
    const urls = extractLinksFromClass(html, 'schedules_id');
    const followers = extractTextFromClass(html, 'schedules_follwer');
    
    const maxLength = Math.max(names.length, urls.length, followers.length);
    for (let i = 0; i < maxLength; i++) {
      schedules.push({
        name: names[i] || '',
        url: urls[i]?.url || '',
        followers: followers[i] || ''
      });
    }
  }
  
  return schedules;
}

// üîó schedules_id„ÇØ„É©„ÇπÂ∞ÇÁî®URLÊäΩÂá∫Èñ¢Êï∞
function extractSchedulesIdUrls(html) {
  const urls = [];
  
  // ÊñπÊ≥ï1: schedules_id„ÇØ„É©„Çπ„Åã„ÇâÁõ¥Êé•hrefÂ±ûÊÄß„ÇíÊäΩÂá∫
  const scheduleIdPattern = /<[^>]*class="[^"]*schedules_id[^"]*"[^>]*href="([^"]*)"[^>]*>/g;
  let match;
  
  while ((match = scheduleIdPattern.exec(html)) !== null) {
    const url = match[1].trim();
    if (url && url !== '#') {
      urls.push({
        url: url,
        type: detectUrlType(url),
        source: 'schedules_id_direct'
      });
    }
  }
  
  // ÊñπÊ≥ï2: schedules_id„ÇØ„É©„ÇπÂÜÖ„ÅÆa„Çø„Ç∞„Åã„ÇâhrefÊäΩÂá∫
  const scheduleIdSectionPattern = /<[^>]*class="[^"]*schedules_id[^"]*"[^>]*>([\s\S]*?)<\/[^>]+>/g;
  let sectionMatch;
  
  while ((sectionMatch = scheduleIdSectionPattern.exec(html)) !== null) {
    const linkPattern = /<a[^>]*href="([^"]*)"[^>]*>/g;
    let linkMatch;
    
    while ((linkMatch = linkPattern.exec(sectionMatch[1])) !== null) {
      const url = linkMatch[1].trim();
      if (url && url !== '#') {
        // ÈáçË§á„ÉÅ„Çß„ÉÉ„ÇØ
        const exists = urls.some(item => item.url === url);
        if (!exists) {
          urls.push({
            url: url,
            type: detectUrlType(url),
            source: 'schedules_id_nested'
          });
        }
      }
    }
  }
  
  return urls;
}

// üéØ URLÁ®ÆÂà•Âà§ÂÆöÈñ¢Êï∞
function detectUrlType(url) {
  if (!url) return 'unknown';
  
  const urlLower = url.toLowerCase();
  
  if (urlLower.includes('youtube.com') || urlLower.includes('youtu.be')) {
    return 'youtube';
  } else if (urlLower.includes('twitter.com') || urlLower.includes('x.com')) {
    return 'twitter';
  } else if (urlLower.includes('twitch.tv')) {
    return 'twitch';
  } else if (urlLower.includes('instagram.com')) {
    return 'instagram';
  } else if (urlLower.includes('tiktok.com')) {
    return 'tiktok';
  } else if (urlLower.includes('discord.gg') || urlLower.includes('discord.com')) {
    return 'discord';
  } else if (urlLower.includes('niconico.com') || urlLower.includes('nicovideo.jp')) {
    return 'niconico';
  } else if (urlLower.includes('openrec.tv')) {
    return 'openrec';
  } else if (urlLower.includes('mildom.com')) {
    return 'mildom';
  } else if (urlLower.includes('showroom-live.com')) {
    return 'showroom';
  } else if (urlLower.includes('17live.co') || urlLower.includes('17.live')) {
    return '17live';
  } else if (urlLower.includes('mirrativ.com')) {
    return 'mirrativ';
  } else if (urlLower.startsWith('http')) {
    return 'web';
  } else {
    return 'other';
  }
}

// HTML„Éë„Éº„ÇπingÈñ¢Êï∞Áæ§
function findGenderData(html) {
  const genderPatterns = [
    { pattern: /ÊÄßÂà•\s*[:Ôºö]\s*([Áî∑Â•≥ÊÄß]\w*)/i, confidence: 0.9 },
    { pattern: /gender\s*[:Ôºö]\s*([Áî∑Â•≥])/i, confidence: 0.8 },
    { pattern: /(Áî∑ÊÄß|Â•≥ÊÄß|Áî∑|Â•≥)/i, confidence: 0.6 }
  ];
  
  for (const { pattern, confidence } of genderPatterns) {
    const match = html.match(pattern);
    if (match) {
      const gender = match[1].includes('Â•≥') ? 'Â•≥ÊÄß' : 
                   match[1].includes('Áî∑') ? 'Áî∑ÊÄß' : match[1];
      return { gender, confidence };
    }
  }
  
  return null;
}

function extractTextFromClass(html, className) {
  const regex = new RegExp(`<[^>]*class="[^"]*${className}[^"]*"[^>]*>([\\s\\S]*?)</[^>]*>`, 'gi');
  const matches = [];
  let match;
  
  while ((match = regex.exec(html)) !== null) {
    const content = match[1].replace(/<[^>]*>/g, '').trim();
    if (content) {
      matches.push(content);
    }
  }
  
  return matches;
}

function parseProfileInfo(profileTexts) {
  const info = {};
  
  profileTexts.forEach(text => {
    const ageMatch = text.match(/Âπ¥ÈΩ¢\s*[:Ôºö]\s*(\d+)/);
    if (ageMatch) info.age = parseInt(ageMatch[1]);
    
    const heightMatch = text.match(/Ë∫´Èï∑\s*[:Ôºö]\s*(\d+)/);
    if (heightMatch) info.height = parseInt(heightMatch[1]);
    
    const birthdayMatch = text.match(/Ë™ïÁîüÊó•\s*[:Ôºö]\s*([^\n]+)/);
    if (birthdayMatch) info.birthday = birthdayMatch[1].trim();
    
    const hobbyMatch = text.match(/Ë∂£Âë≥\s*[:Ôºö]\s*([^\n]+)/);
    if (hobbyMatch) info.hobbies = hobbyMatch[1].trim();
  });
  
  return info;
}


function extractCSRFToken(html) {
  const match = html.match(/<meta name="csrf-token" content="([^"]+)"/);
  return match ? match[1] : null;
}

function extractHiddenFields(html) {
  const fields = {};
  const hiddenInputRegex = /<input[^>]*type="hidden"[^>]*>/g;
  let match;
  
  while ((match = hiddenInputRegex.exec(html)) !== null) {
    const input = match[0];
    const nameMatch = input.match(/name="([^"]+)"/);
    const valueMatch = input.match(/value="([^"]*)"/);
    
    if (nameMatch && valueMatch) {
      fields[nameMatch[1]] = valueMatch[1];
    }
  }
  
  return fields;
}

function extractFormAction(html) {
  const match = html.match(/<form[^>]*action="([^"]+)"/);
  return match ? match[1] : null;
}

// Âü∫Êú¨„Éá„Éº„Çø„Å®Ë©≥Á¥∞„Éá„Éº„Çø„ÇíÁµ±Âêà„Åó„Å¶„Ç¢„Éó„É™Áî®„ÅÆlatest_data„ÇíÊõ¥Êñ∞
async function integrateDataForApp(env, detailedLivers) {
  try {
    console.log('üîÑ Starting data integration for app...');

    // Âü∫Êú¨„Éá„Éº„Çø„ÇíÂèñÂæó
    const basicDataStr = await env.LIVER_DATA?.get('latest_basic_data');
    if (!basicDataStr) {
      console.log('‚ö†Ô∏è No basic data found for integration');
      return;
    }

    const basicData = JSON.parse(basicDataStr);
    const basicLivers = basicData.data || [];

    // Ë©≥Á¥∞„Éá„Éº„Çø„ÇíoriginalId„Åß„Ç§„É≥„Éá„ÉÉ„ÇØ„ÇπÂåñ
    const detailsMap = new Map();
    detailedLivers.forEach(liver => {
      if (liver.originalId) {
        detailsMap.set(liver.originalId, liver);
      }
    });

    // Âü∫Êú¨„Éá„Éº„Çø„Å´Ë©≥Á¥∞„Éá„Éº„Çø„Çí„Éû„Éº„Ç∏
    const integratedData = basicLivers.map(basicLiver => {
      const details = detailsMap.get(basicLiver.originalId);

      if (details && details.hasDetails) {
        // Ë©≥Á¥∞„Éá„Éº„Çø„ÅåÂ≠òÂú®„Åô„ÇãÂ†¥Âêà„ÅØ„Éû„Éº„Ç∏
        return {
          ...basicLiver,
          ...details,
          // ÈáçË¶Å„Å™„Éï„Ç£„Éº„É´„Éâ„ÇíÊòéÁ§∫ÁöÑ„Å´Áµ±Âêà
          id: basicLiver.originalId, // originalId„Çí‰ΩøÁî®
          imageUrl: `/api/images/${basicLiver.originalId}.jpg`,
          hasDetails: true
        };
      } else {
        // Ë©≥Á¥∞„Éá„Éº„Çø„Åå„Å™„ÅÑÂ†¥Âêà„ÅØÂü∫Êú¨„Éá„Éº„Çø„ÅÆ„Åø
        return {
          ...basicLiver,
          id: basicLiver.originalId,
          imageUrl: `/api/images/${basicLiver.originalId}.jpg`,
          hasDetails: false,
          categories: [],
          streamingUrls: []
        };
      }
    });

    // Áµ±ÂêàÊ∏à„Åø„Éá„Éº„Çø„Çílatest_data„Å´‰øùÂ≠ò
    const integratedResult = {
      success: true,
      total: integratedData.length,
      data: integratedData,
      timestamp: Date.now(),
      lastUpdate: new Date().toISOString(),
      integration: {
        basicCount: basicLivers.length,
        detailCount: detailedLivers.length,
        withDetails: integratedData.filter(l => l.hasDetails).length,
        pending: integratedData.filter(l => !l.hasDetails).length
      }
    };

    await env.LIVER_DATA?.put('latest_data', JSON.stringify(integratedResult));
    console.log(`‚úÖ Data integration completed: ${integratedData.length} total, ${integratedResult.integration.withDetails} with details`);

  } catch (error) {
    console.error('‚ùå Data integration failed:', error);
    // Áµ±ÂêàÂ§±ÊïóÊôÇ„ÅØ„Ç®„É©„Éº„Çí„É≠„Ç∞„Å´Ë®òÈå≤„Åô„Çã„ÅåÂá¶ÁêÜ„ÅØÁ∂ôÁ∂ö
  }
}

function sleep(ms) {
  return new Promise(resolve => setTimeout(resolve, ms));
}

// „É¶„Éã„Éº„ÇØIDÁîüÊàêÈñ¢Êï∞
function generateUniqueId(liver) {
  // originalId„ÇíÂü∫Ê∫ñ„Å´„É¶„Éã„Éº„ÇØID„ÇíÁîüÊàê
  const originalId = liver.originalId || liver.id;
  const pageNumber = liver.page || liver.pageNumber || 1;
  const cleanName = liver.name ? liver.name.replace(/[^a-zA-Z0-9]/g, '').substring(0, 8) : 'liver';
  
  // originalId„ÇíÂê´„ÇÅ„Çã„Åì„Å®„Åß‰∏ÄÊÑèÊÄß„Çí‰øùË®º
  return `${cleanName}_${originalId}_p${pageNumber}_${Date.now()}`;
}

// CPUÊôÇÈñìÂà∂ÈôêÂØæÂøúÔºöÂ∞è„Åï„Å™„Éê„ÉÉ„ÉÅ„ÅßÊÆµÈöéÁöÑÂá¶ÁêÜ
async function processSmallBatch(env, livers, maxItems = 3) {
  console.log(`üîç Starting small batch processing: ${livers.length} total livers, max ${maxItems} per execution`);
  
  // Âá¶ÁêÜÊ∏à„ÅøÁä∂ÊÖã„ÇíÂèñÂæó
  const progressKey = 'detail_processing_progress';
  const progressStr = await env.LIVER_DATA?.get(progressKey);
  let processed = progressStr ? JSON.parse(progressStr) : { completed: [], lastIndex: 0 };
  
  // Êú™Âá¶ÁêÜ„ÅÆ„É©„Ç§„Éê„Éº„ÇíÁâπÂÆö
  const startIndex = processed.lastIndex || 0;
  const batchLivers = livers.slice(startIndex, startIndex + maxItems);
  
  if (batchLivers.length === 0) {
    console.log('‚úÖ All livers have been processed, resetting progress');
    await env.LIVER_DATA?.delete(progressKey);
    
    // Worker3„Çí„Éà„É™„Ç¨„Éº
    await triggerImageWorker(env);
    await updateWorkerStatus(env, 'details', 'completed', {
      processed: processed.completed.length,
      total: livers.length,
      timestamp: Date.now()
    });
    return;
  }
  
  console.log(`üì¶ Processing batch: ${startIndex + 1}-${startIndex + batchLivers.length} of ${livers.length}`);
  
  // „É≠„Ç∞„Ç§„É≥„Çª„ÉÉ„Ç∑„Éß„É≥ÂèñÂæó
  let loginResult = await getStoredSession(env);
  if (!loginResult || !loginResult.success) {
    loginResult = await performRobustLogin(env);
    if (!loginResult.success) {
      throw new Error(`Login failed: ${loginResult.error}`);
    }
    await storeSession(env, loginResult);
  }
  
  let successCount = 0;
  let errorCount = 0;

  // „Çø„Ç§„É†„Ç¢„Ç¶„ÉàÁõ£Ë¶ñË®≠ÂÆöÔºàÂÆâÂÖ®„Éû„Éº„Ç∏„É≥Ôºâ
  const TIMEOUT_LIMIT = 30000; // 30ÁßíÂà∂Èôê
  const startTime = Date.now();

  // ÊúÄÈÅ©Âåñ„Åï„Çå„Åü„Éê„ÉÉ„ÉÅÂá¶ÁêÜ
  for (const liver of batchLivers) {
    // „Çø„Ç§„É†„Ç¢„Ç¶„Éà„ÉÅ„Çß„ÉÉ„ÇØ
    if (Date.now() - startTime > TIMEOUT_LIMIT) {
      console.log('‚è±Ô∏è Timeout approaching, saving progress and exiting...');
      break;
    }
    try {
      const detailInfo = await scrapeDetailPageWithAuth(liver.detailUrl, loginResult.cookies, loginResult.userAgent, env, loginResult);
      
      if (detailInfo) {
        // „É¶„Éã„Éº„ÇØID„Å®ÁîªÂÉèURL„ÇíÁîüÊàê
        const uniqueId = generateUniqueId(liver);
        const imageUrl = `/api/images/${liver.originalId}.jpg`;
        
        const detailedLiver = {
          ...liver,
          ...detailInfo,
          id: uniqueId,
          imageUrl: imageUrl,
          updatedAt: Date.now(),
          hasDetails: true,
          detailScrapedAt: new Date().toISOString()
        };
        
        processed.completed.push(detailedLiver);
        successCount++;
        console.log(`‚úÖ ${liver.name} - Details collected (ID: ${uniqueId})`);
      } else {
        // Ë©≥Á¥∞ÊÉÖÂ†±„Åå„Å™„ÅÑÂ†¥Âêà„ÇÇ„É¶„Éã„Éº„ÇØID„ÇíÁîüÊàê
        const uniqueId = generateUniqueId(liver);
        const imageUrl = `/api/images/${liver.originalId}.jpg`;
        
        processed.completed.push({
          ...liver,
          id: uniqueId,
          imageUrl: imageUrl,
          updatedAt: Date.now(),
          hasDetails: false
        });
        console.log(`‚ö†Ô∏è ${liver.name} - No details found (ID: ${uniqueId})`);
      }
      
      // „É™„ÇØ„Ç®„Çπ„ÉàÈñì„ÅÆÂæÖÊ©ü„ÇíÁü≠Á∏Æ„Åó„Å¶„Çª„ÉÉ„Ç∑„Éß„É≥Á∂≠ÊåÅ
      await sleep(500);
      
    } catch (error) {
      console.error(`‚ùå ${liver.name} - Detail scraping failed:`, error.message);
      
      // Ë™çË®ºÂ§±ÊïóÊôÇ„ÅØÂÜç„É≠„Ç∞„Ç§„É≥
      if (error.message.includes('Ë™çË®ºÂ§±Êïó')) {
        try {
          loginResult = await performRobustLogin(env);
          if (loginResult.success) {
            await storeSession(env, loginResult);
            console.log('üîÑ Re-login successful');
          }
        } catch (reloginError) {
          console.error('‚ùå Re-login failed:', reloginError.message);
        }
      }
      
      // „Ç®„É©„ÉºÊôÇ„ÇÇ„É¶„Éã„Éº„ÇØID„ÇíÁîüÊàê
      const uniqueId = generateUniqueId(liver);
      const imageUrl = `/api/images/${liver.originalId}.jpg`;
      
      processed.completed.push({
        ...liver,
        id: uniqueId,
        imageUrl: imageUrl,
        updatedAt: Date.now(),
        hasDetails: false,
        detailError: error.message
      });
      errorCount++;
    }
  }
  
  // ÈÄ≤Êçó„Çí‰øùÂ≠ò
  processed.lastIndex = startIndex + batchLivers.length;
  await env.LIVER_DATA?.put(progressKey, JSON.stringify(processed));
  
  // Ë©≥Á¥∞„Éá„Éº„Çø„Çí‰øùÂ≠ò
  if (processed.completed.length > 0) {
    await env.LIVER_DATA?.put('latest_detailed_data', JSON.stringify({
      timestamp: Date.now(),
      total: processed.completed.length,
      data: processed.completed,
      lastUpdate: new Date().toISOString(),
      processed: processed.completed.filter(l => l.hasDetails).length,
      errors: processed.completed.filter(l => l.detailError).length
    }));

    // Âü∫Êú¨„Éá„Éº„Çø„Å®Áµ±Âêà„Åó„Å¶„Ç¢„Éó„É™Áî®„ÅÆlatest_data„ÇíÊõ¥Êñ∞
    await integrateDataForApp(env, processed.completed);
  }
  
  // ÈÄ≤ÊçóÁä∂Ê≥Å„ÇíÊõ¥Êñ∞
  await updateWorkerStatus(env, 'details', 'in_progress', {
    total: livers.length,
    processed: processed.completed.length,
    successCount: successCount,
    errorCount: errorCount,
    lastBatch: `${startIndex + 1}-${startIndex + batchLivers.length}`,
    nextExecution: processed.lastIndex < livers.length ? 'scheduled in 2 hours' : 'completed'
  });
  
  console.log(`‚úÖ Small batch completed: ${successCount} success, ${errorCount} errors`);
  console.log(`üìä Overall progress: ${processed.completed.length}/${livers.length} (${Math.round(processed.completed.length/livers.length*100)}%)`);
}

// „Çª„ÉÉ„Ç∑„Éß„É≥ÁÆ°ÁêÜÈñ¢Êï∞Áæ§
async function getStoredSession(env) {
  if (!env.LIVER_DATA) return null;
  
  try {
    const sessionData = await env.LIVER_DATA.get('login_session');
    if (!sessionData) return null;
    
    const session = JSON.parse(sessionData);
    const now = Date.now();
    const sessionAge = now - session.timestamp;
    const maxAge = 30 * 60 * 1000; // 30ÂàÜ
    
    if (sessionAge > maxAge) {
      console.log('üîÑ Stored session expired');
      await env.LIVER_DATA.delete('login_session');
      return null;
    }
    
    console.log(`üîÑ Found valid session (age: ${Math.round(sessionAge / 1000)}s)`);
    return session;
  } catch (error) {
    console.error('‚ùå Failed to get stored session:', error.message);
    return null;
  }
}

async function storeSession(env, loginResult) {
  if (!env.LIVER_DATA || !loginResult.success) return;
  
  try {
    const sessionData = {
      success: true,
      cookies: loginResult.cookies,
      timestamp: Date.now()
    };
    
    await env.LIVER_DATA.put('login_session', JSON.stringify(sessionData), {
      expirationTtl: 30 * 60 // 30ÂàÜ„ÅßTTLË®≠ÂÆö
    });
    
    console.log('üíæ Session stored successfully');
  } catch (error) {
    console.error('‚ùå Failed to store session:', error.message);
  }
}